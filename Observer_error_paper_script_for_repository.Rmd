---
title: "Observer_error_paper_script_for_repository"
author: "Anonymous for double-blind review"
date: "2025-06-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library}
library(vegan)
library(tidyverse)
library(Factoshiny)
library(tibble)
library(maptools)
library(colormap)
library(purrr)
library(ggplot2)
library(dplyr)
library(sf)
library(grid)
library(ggdendro)
library(cluster)
library(dendextend)
library(factoextra)
library(rgeos)
library(ggmap)
library(rgdal)
library(labdsv)
library(ggrepel)
library(adespatial)
library(colorspace)
library(corrplot)
library(spatstat)
library(ade4)
library(adegraphics)
library(scales)
library(FactoMineR)
library(factoextra)
library(tictoc)
library(car)
library(geodist)
library(rstatix)
library(ecospat)
library(betareg)
library(foreach)
library(doParallel)
library(rstatix)
library(ggpubr)
library(emmeans)
library(drc)
library(viridis)

# custom shuffling functions
source("shuff_cdm2.R")
source("shuff_cdm_fam2.R")


## Box-Cox-Chord transformation (Legendre & Borcard, 2018, Appendix 4)
box.cox.chord <- function(mat, bc.exp=0) { 
# Internal function
vec.norm <- function(vec) sqrt(sum(vec^2))
#
chck <- apply(mat, 1, sum)
if(any(chck == 0)) stop("Rows",which(chck==0)," of the data matrix sum to 0")
#
# Apply the user-selected Box-Cox exponent (bc.exp) to the frequency data
if(bc.exp==0) {
 tmp <- log(mat+1) 
 } else { 
 tmp <- mat^bc.exp 
 }
row.norms <- apply(tmp, 1, vec.norm)
#
# Apply the chord transformation to matrix "tmp" before returning it
res <- sweep(tmp, 1, row.norms, "/")
 }
```

```{r Load data}

###. (1) Load environmental data /. metadata
env <- read.csv("env_for_repository.csv") %>% 
  dplyr::select(-X) %>% 
  column_to_rownames(var = "plot_name")

## extract coordinates
coord <- env %>% 
  dplyr::select(ddlon, ddlat)

### (2) load community data
community_data <- readRDS("community_data.rds")

### (3) Load flora
flora <- read.csv("flora_for_observer_error_paper.csv", sep = ",") %>% 
  dplyr::select(-X)
  
### (4) Load morphospecies list
morpho_spp <- read.csv("morpho_spp_for_repository.csv", sep = ",") %>% 
  dplyr::select(-X)

```

```{r Environmental predictors}

#### (A.) Variable loading ####

## (1) Select environmental variables [clim, soil, topo, human]
climate_vars <- c("BIO01", "BIO02", "BIO03", "BIO04", "BIO05", "BIO06", "BIO07", "BIO08", "BIO09", "BI010", "BIO11", "BIO12", "BIO13", "BIO14", "BIO15", "BIO16", "BIO17", "BIO18", "BIO19", "CLOUDinter", "CLOUDintra", "CLOUDmean", "CLOUDseason")
topo_vars <- c("aspect", "cnd", "ci", "elev", "hand", "lsf", "plc", "prc", "tca", "vd", "twi", "slope")
human_vars <- c("api", "hapi")
soil_vars <- c("Al", "Ca", "Cu", "Fe", "Mg", "Mn",  "P", "K", "Zn", "pH", "Sand", "OM", "cec")


#### (B.) Variable selection ####
### (1) Soil+topo variables
# select variables
env_soiltopo_all <- env %>% 
  dplyr::select(any_of(c(topo_vars, soil_vars)))

## (1.2) Test for collinearity in explanatory variables
# correlation matrix
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_all, method = "pearson"))
# p-value of correlation test
testRes = cor.mtest(env_soiltopo_all, conf.level = 0.95)

## Visually inspect correlation diagram
dev.off()
par(mfrow = c(1,1))
corrplot(cor(env_soiltopo_all),
         p.mat = testRes$p,
         method = 'circle', 
         type = 'lower', 
         insig='blank',
         addCoef.col ='black', 
         number.cex = 0.2,
         tl.cex = 0.5,
         tl.col = 'black',
         order = 'AOE', 
         diag=FALSE)

## (1.3) manually discard soil and topo variables based on their correlation and ecological background knowledge
# 1
env_soiltopo_sel <- env_soiltopo_all %>% dplyr::select(-"cnd") # CND is correlated with HAND and PRC
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 2
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"ci") # CI is correlated with TWI
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 3
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"prc") # PRC is correlated with HAND
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 4
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"lsf") # LSF is correlated with TCA
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 5
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"twi") # TWI is correlated with Slope and HAND
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 6
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"vd") # VD is correlated with HAND and Elev
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 7
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"tca") # TCA is almost zero variance
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 8
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"Mg") # Mg is correlated with Ca and Pb
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 9
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"OM") # OM is correlated with Fe and P
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 10
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"Fe") # Fe is correlated with K and P
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 11
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"Zn") # Zn is correlated with K
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 13
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"elev") # Elev is correlated with climate
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))
# 14
env_soiltopo_sel <- env_soiltopo_sel %>% dplyr::select(-"cec") # CEC is correlated with K, Al and Sand
env_soiltopo_cm <- as.data.frame(cor(env_soiltopo_sel, method = "pearson"))

## (1.4) Inspect correlations after selection
# maximum value correlation
(env_soil_max_corr <- max(env_soiltopo_cm[env_soiltopo_cm != 1], na.rm = TRUE))



### (2) Climate variables
# select variables
env_climate_all <- env %>% 
  dplyr::select(any_of(climate_vars))

## (2.2) Test for collinearity in explanatory variables
# correlation matrix
env_climate_cm <- as.data.frame(cor(env_climate_all, method = "pearson"))
# get p-value of correlation test
testRes = cor.mtest(env_climate_all, conf.level = 0.95)

## visually inspect correlation diagram
# dev.off()
# par(mfrow = c(1,1))
corrplot(cor(env_climate_all),
         p.mat = testRes$p,
         method = 'circle', 
         type = 'lower', 
         insig='blank',
         addCoef.col ='black', 
         number.cex = 0.2,
         tl.cex = 0.5,
         tl.col = 'black',
         order = 'AOE', 
         diag=FALSE)

## (2.3) manually discard variables based on their correlation and ecological background knowledge
# 1
env_climate_sel <- env_climate_all %>% dplyr::select(-"BIO05", -"BIO06", -"BIO08", -"BIO09", -"BIO11") # correlated with BIO01
env_climate_cm <- as.data.frame(cor(env_climate_sel, method = "pearson"))
# 2
env_climate_sel <- env_climate_sel %>% dplyr::select(-"BIO02") # correlated with precipitation variables
env_climate_cm <- as.data.frame(cor(env_climate_sel, method = "pearson"))
# 3
env_climate_sel <- env_climate_sel %>% dplyr::select(-"BIO03") # correlated with BIO04
env_climate_cm <- as.data.frame(cor(env_climate_sel, method = "pearson"))
# 4
env_climate_sel <- env_climate_sel %>% dplyr::select(-"BIO04") # correlated with BIO15
env_climate_cm <- as.data.frame(cor(env_climate_sel, method = "pearson"))
# 5
env_climate_sel <- env_climate_sel %>% dplyr::select(-"BIO07") # correlated with precipitation variables
env_climate_cm <- as.data.frame(cor(env_climate_sel, method = "pearson"))
# 6
env_climate_sel <- env_climate_sel %>% dplyr::select(-"BIO13", -"BIO14") # correlated with precipitation variables
env_climate_cm <- as.data.frame(cor(env_climate_sel, method = "pearson"))
# 7
env_climate_sel <- env_climate_sel %>% dplyr::select(-"BIO16", -"BIO17", -"BIO18", -"BIO19") # correlated with precipitation variables
env_climate_cm <- as.data.frame(cor(env_climate_sel, method = "pearson"))
# 8
env_climate_sel <- env_climate_sel %>% dplyr::select(-"CLOUDinter", -"CLOUDintra") # correlated with precipitation variables
env_climate_cm <- as.data.frame(cor(env_climate_sel, method = "pearson"))


## (2.4) Inspect correlations after selection
# maximum value correlation
(env_climate_max_corr <- max(env_climate_cm[env_climate_cm != 1], na.rm = TRUE))


### (3) assemble human activity dataset
env_human_sel <- env %>% dplyr::select(api, hapi)

### (4) assemble env_sel dataframe
env_sel <- cbind(env_soiltopo_sel, env_climate_sel, env_human_sel)

## plot correlation circles of entire dataset
# get p-value of correlation test
testRes = cor.mtest(env_sel, conf.level = 0.95)
# dev.off()
corrplot(cor(env_sel),
         p.mat = testRes$p,
         method = 'circle', 
         type = 'lower', 
         insig='blank',
         addCoef.col ='black', 
         number.cex = 0.2,
         tl.cex = 0.5,
         tl.col = 'black',
         order = 'AOE', 
         diag=FALSE)



#### (C.) Transformation of environmental dataset (Box-Cox) ####
### Box Cox transformation in R, The Box-Cox transformation is a power transformation that eliminates nonlinearity between variables, differing variances, and variable asymmetry.

# unname matrix to get purely numeric vectors
expvar <- env_sel

# Visualisation of explanatory variables prior transformation
par(mfrow= c(4, 6), mar= c(2,0,2,0.2)+0.1)
for(i in 1:length(expvar)){  
plot(density(expvar[,i]), main = colnames(expvar)[i], yaxt ="n", bty ="n") 
rug(expvar[,i],col="blue") 
abline(v=mean(expvar[,i]),col ="red")
}

# Create empty dataframe to capture lambda value for each variable
lamb <- data.frame(matrix(NA,
                          nrow = ncol(expvar),
                          ncol = 1))
colnames(lamb) <- "x"
Env <- expvar
Env.bc <- expvar

## Box-Cox transformation with car package in for loop
# if code bugs at a given i, verify if column is corrupt and delete from dataframe
for(i in 1:length(expvar)){
  Env[,i]=Env[,i]+ abs(min(Env[,i]))+0.00001 # add value to produce non-negative values
  x <- car::powerTransform(Env[,i])
  lamb[i,]=x$lambda
  #transformation de la colonne i avec paramètre lambda trouvé avec la fonction bcPower()
  Env.bc[,i]=car::bcPower(Env[,i], (lamb[i,]), jacobian.adjusted = FALSE)
}

# Add rownames and colnames to Env.bc
rownames(Env.bc) <- rownames(expvar)
colnames(Env.bc) <- colnames(expvar)

# Add rownames to lambda value table
lamb <- lamb %>% rename(lambda = "x")
lamb$var <- colnames(expvar)

# set variables with lambda > 3 to lambda = 3
lamb <- lamb %>% 
  mutate(lambda = pmin(pmax(lambda, -3), 3))

# Verify normal distributions after transformations
par(mfrow= c(4, 6), mar= c(2,0,2,0.2)+0.1)
for(i in 1:ncol(expvar)){
plot(density(Env.bc[,i]), main = colnames(Env.bc)[i], yaxt ="n", bty ="n") 
rug(Env.bc[,i],col="blue") 
abline(v=mean(Env.bc[,i]),col ="red")
}

## Final dataset of Box-Cox transformed variables
env_bc <- as.data.frame(Env.bc)

rm(Env, Env.bc, expvar, x) # remove unnecessary variables

```

```{r phylogenetic niche conservatism}
## This chunk tests the association between a phylogenetic distance matrix on the one side and geographical / environmental distances on the other using Mantel tests. It follows the approach proposed by TD on 2 December 2024 by (a) calculating species-wise centered (mean) coordinates to construct a species-by-species geodist matrix and (b) using species-wise mean environmental parameters to construct a species-by-species envdist matrix.


library(V.PhyloMaker)  # function phylo.maker()
library(V.PhyloMaker2)

### Environmental distance
# calculate species-wise means for selected(!) environmental variables
mean_env <- bind_rows(community_data) %>% 
  filter(plot_name %in% rownames(env_sel)) %>% 
  filter(!is.na(tax_sp_level)) %>% 
  dplyr::select(plot_name, tax_sp_level) %>%
  # distinct(plot_name, tax_sp_level, .keep_all = TRUE) %>% ## abundance-weighted distances
  left_join(., env_sel %>% rownames_to_column(var = "plot_name"), by = "plot_name") %>% 
  group_by(tax_sp_level) %>% 
  summarise(
    across(
      .cols = colnames(env_sel),
      .fns = mean,
      na.rm = TRUE
    )
  ) %>% 
  column_to_rownames(var = "tax_sp_level")

# delete negative columns
negative_columns <- colnames(mean_env)[apply(mean_env, 2, function(x) any(x < 0))]
mean_env <- mean_env %>% dplyr::select(-negative_columns)

## (2) envdist calculated on averaged raw environmental predictors
# envdist matrix on untransformed environmental data
envdist <- as.data.frame(as.matrix(vegdist(mean_env), method = "euclidean", na.rm = TRUE))


### Phylogenetic distance

## read flora data
mik1 <- read.csv("flora_for_phylo_tree.csv", header = TRUE, sep = ";", dec =",") %>% 
  mutate(family = ifelse(genus == "Grewia", "Malvaceae", family)) %>%  
    mutate(family = ifelse(genus == "Pogonophora", "Peraceae", family)) %>%  
    mutate(family = ifelse(genus == "Calamus", "Arecaceae", family)) %>%
    mutate(family = ifelse(genus == "Pentabrachion", "Phyllanthaceae", family))

mik1 <- flora %>% 
  rename(species = "tax_esp",
         genus = "tax_gen",
         family = "tax_fam") %>% 
  dplyr::select(-fam_count, -gen_count) %>% 
  mutate(family = ifelse(genus == "Grewia", "Malvaceae", family)) %>%  
    mutate(family = ifelse(genus == "Pogonophora", "Peraceae", family)) %>%  
    mutate(family = ifelse(genus == "Calamus", "Arecaceae", family)) %>%
    mutate(family = ifelse(genus == "Pentabrachion", "Phyllanthaceae", family))

# build phylogenetic tree with phylo.maker
tree.mik <- phylo.maker(sp.list = mik1, tree = GBOTB.extended, nodes = nodes.info.1, scenarios="S3")

# get phylodist matrix
phylodist <- as.data.frame(cophenetic.phylo(tree.mik$scenario.3)) %>%
  arrange(rownames(.)) %>% 
  dplyr::select(order(names(.)))
rownames(phylodist) <- gsub("_", " ", rownames(phylodist)) # synchronize species names
colnames(phylodist) <- gsub("_", " ", colnames(phylodist)) # synchronize species names


## (4) synchronize matrices relative to the envdist matrix
if (!identical(rownames(phylodist), rownames(envdist))) {
  
  # remove species in envdist for which we have no info in phylodist
  envdist_to_use <- envdist %>% 
    dplyr::select(any_of(colnames(phylodist))) %>%
    rownames_to_column(var = "species") %>% 
    filter(species %in% rownames(phylodist)) %>% 
    column_to_rownames(var = "species")
  
  # remove species in phylodist for which we have no info in envdist
  phylodist_to_use <- phylodist %>% 
    dplyr::select(any_of(colnames(envdist_to_use))) %>% 
    rownames_to_column(var = "species") %>% 
    filter(species %in% colnames(envdist_to_use)) %>% 
    column_to_rownames(var = "species")
}


## (5) Calculate matrix correlation via Mantel test
(results.mantel <- mantel(
  xdis = envdist_to_use,
  ydis = phylodist_to_use,
  method = "pearson",
  permutations = 999, 
  na.rm = TRUE))
```

```{r Contribution versus abundance, echo=FALSE}

### Here, we explore whether the species that contribute disproportionally to  R2 are common species and generalists.

nperm_rda <- 999
bcc_exp_list <- list(0, 0.25, 0.5, 1)

plot_list <- list()

for (h in c("understory", "canopy")) {
  
  #### (A) Define community data and calculate commonness measures ####
  
  ## (1) Choose community data
  community_data_sel <- community_data[[h]]
  
  
  cdm <- community_data_sel %>% 
    filter(plot_name %in% rownames(env_sel)) %>% 
    filter(!is.na(tax_sp_level)) %>% 
    group_by(plot_name) %>%
    dplyr::count(tax_sp_level) %>%
    reshape::cast(.,
                  plot_name ~ tax_sp_level,
                  value='n') %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    column_to_rownames(., var = "plot_name")
  
  
  
  ## (2) Get measures for commonness
  # (2.1) frequency = number of site occurrences per species
  frequency <- as.data.frame(apply(cdm, 2, function(x) sum(x != 0))) %>%
    rownames_to_column(var = "Species") %>%
    rename(frequency = 2) %>% 
    mutate(log_frequency = log(frequency))
  

  # (2.2) total log abundance of all entire dataset
  total_log_abundance <- as.data.frame(colSums(cdm)) %>% 
    rownames_to_column(var = "Species") %>% 
    rename(abd = 2) %>% 
    mutate(log_abd = log(abd))
  
  # (2.3) mean local abundance
  mean_local_abundance <- data.frame(Species = colnames(cdm), mean_local_abd = rep(NA, ncol(cdm)))
  for (i in 1:ncol(cdm)) {
    
    # get number of plots in which species is present
    mean_local_abundance_sp <- cdm[i] %>% 
      rename(Species = 1) %>% 
      filter(Species > 0)
      
    mean_local_abundance[i,2] <- round(sum(mean_local_abundance_sp$Species)/nrow(mean_local_abundance_sp),3)
  }
  
  # combine commonness measures
  commonrare <- left_join(frequency, total_log_abundance, by = "Species") %>% 
    left_join(., mean_local_abundance, by = "Species") %>% 
    mutate(mean_local_log_abd = log(mean_local_abd))
  
  
  
  #### (C): mean global niche breadth ####
  
  # run PCA
  pca <- dudi.pca(env_sel, scale = TRUE, center = TRUE, scannf = FALSE, nf = 10)
  # eigenvalues of first 10 PCaxes
  (variance_exp <- (pca$eig/sum(pca$eig))[1:10])
  # extract site scores
  sitescores <- pca$li
  
  # combine sitescores with community data to get dataframe suitable for nichePOSNB()
  sitescores <- cbind(sitescores, cdm)
  nichebreadth <- ecospat::ecospat.nichePOSNB(sitescores, colvar = c(1:10), colfreq = 11:length(sitescores))
  
  ## weighted mean niche breadth across several axes
  # weights w are rescaled so that their sum equals 1
  mean_niche_breadth <- ecospat.nicheNBmean(nichebreadth, w = variance_exp) %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "Species") %>% 
    mutate(Species = str_replace_all(Species, "\\.", " ")) %>% 
    filter(NBmean > 0)
  
  
  
  #### (D) contribution to RDA ####
  
  ## list of graph-based MEM spatial predictors for

  # Chose spatial weighting matrix
  mem_candidates <- listw.candidates(
    coord, # list of point coordinates
    nb = c("mst", "gab"), # test for minimum spanning tree (mst) and Gabriel's graph (gab)
    weights = c("binary", "flin")) # test for neutral and linear weighting matrices
  
  # Select Spatial weighting matrix (SWM)
  mem_select <- adespatial::listw.select(cdm,
                                         mem_candidates,
                                         method = "FWD",
                                         MEM.autocor = "positive",
                                         nperm = nperm_rda, # reduced to reduce computational time
                                         nperm.global = nperm_rda) # run forward selection
  
  
  # test results of global model test
  mem_select$best$global.test
  # Summary of listw.select
  mem_select$best$summary
  
  # capture MEMs of listw.select in dataframe
  gbmem <- as.data.frame(mem_select$best$MEM.select)
  
  # join with environmental data if not empty
  if (nrow(env_bc) == nrow(gbmem)) {
    env_rda <- cbind(env_bc, gbmem)
  } else {
    env_rda <- env_bc
  }
  
  
  cdm_bcc_list <- list()
  rda_r2_list <- list()
  
  ## find optimal BCC transformation coefficient by identifying the highest R2ajd for global RDA
  for (i in 1:length(bcc_exp_list)) {
    
    cdm_bcc_list[[i]] <- box.cox.chord(cdm, bc.exp = bcc_exp_list[[i]])
    
    rda_temp <- vegan::rda(cdm_bcc_list[[i]] ~ ., env_rda, na=na.omit, subset = complete.cases(cdm), scale=FALSE)
    
    rda_r2_list[[i]] <- RsquareAdj(rda_temp)$adj.r.squared
    
    rm(rda_temp)
  }
  
  
  # get community data matrix with transformed frequencies
  cdm_bcc <- cdm_bcc_list[[which.max(unlist(rda_r2_list))]]
  
  
  # run RDA
  rda <- vegan::rda(cdm_bcc ~ ., env_rda, na=na.omit, subset = complete.cases(cdm_bcc),
                    scale=FALSE) # set 'scale = FALSE' if response is CDM
  
  
  # simple species-wise sum of positive species scores of all axes
  # species_scores <- as.data.frame(vegan::scores(rda, display = "species", choices = c(1:length(rda$CCA$eig)))) %>% 
  #   mutate_all(~ abs(.)) %>% # drop negative values
  #   mutate(sum = rowSums(dplyr::select(., everything())))
  
  # get axis eigenvalues
  eigenvalues <- rda$CCA$eig
  
  species_scores <- as.data.frame(vegan::scores(rda, display = "species", choices = c(1:length(rda$CCA$eig))))
  
  # species-wise sum of scores for all axes, multiplied by each respectives axis contribution to total variance explained (constrained inertia)
  spp_contrib_df <- species_scores %>% # get species scores for all RDA axes
    mutate_all(~ abs(.)) %>% # drop negative values
    mutate(across(everything(), ~ . * eigenvalues[which(names(species_scores) == cur_column())])) %>% # multiply all spp scores with the corresponding axis' proportion of total variance explained
    mutate(sum = rowSums(dplyr::select(., everything()))) %>%  # row-wise sums
    dplyr::select(sum) %>% 
    rename(spp_contrib = "sum") %>% 
    rownames_to_column(var = "Species") %>%  ## add commonness measures, niche breadth and generalist proportion
    left_join(., commonrare, by = "Species") %>% 
    left_join(., mean_niche_breadth, by = "Species")
  
  if (exists("clamtest_result")) {
    spp_contrib_df <- spp_contrib_df %>% 
      left_join(., clamtest_result, by = "Species")
  }
  
  
  
  #### (E) Correlations ####
  
  #### (E.1) Correlation among commonness and neach breadth measures ####
  ## check if variables are normally distributed to assess whether to use Pearson or Spearman rank correlation
  shapiro_test(spp_contrib_df$frequency)
  shapiro_test(spp_contrib_df$log_abd)
  shapiro_test(spp_contrib_df$mean_local_log_abd)
  
  spp_contrib_df %>% cor_test(frequency, log_abd, method = "spearman")
  spp_contrib_df %>% cor_test(frequency, mean_local_log_abd, method = "spearman")
  spp_contrib_df %>% cor_test(log_abd, mean_local_log_abd, method = "spearman")
  
  spp_contrib_df %>% cor_test(NBmean, frequency, method = "spearman")
  spp_contrib_df %>% cor_test(NBmean, abd, method = "spearman")
  spp_contrib_df %>% cor_test(NBmean, mean_local_log_abd, method = "spearman")
  
  spp_contrib_df %>% 
    filter(!is.na(NBmean)) %>% 
    cor_test(NBmean, mean_local_abd, method = "spearman")
  
  #### (E.2) Correlation between species contribution and commmonness/niche breadth ####
  spp_contrib_df %>% cor_test(spp_contrib, frequency)
  spp_contrib_df %>% cor_test(spp_contrib, log_abd)
  spp_contrib_df %>% cor_test(spp_contrib, mean_local_log_abd)
  
  spp_contrib_df %>% cor_test(spp_contrib, NBmean)
  
  
  #### (F): Beta regression models ####
  #### (F.1) contribution vs. commonness ####
  # frequency
  betareg_freq <- betareg(spp_contrib ~ frequency, data = spp_contrib_df)
  summary(betareg_freq)
  # frequency
  betareg_log_freq <- betareg(spp_contrib ~ log_frequency, data = spp_contrib_df)
  summary(betareg_log_freq)
  
  # log abundance
  betareg_logabd <- betareg(spp_contrib ~ log_abd, data = spp_contrib_df)
  summary(betareg_logabd)
  # mean local log-transformed abundance
  betareg_local_log_abd <- betareg(spp_contrib ~ mean_local_log_abd, data = spp_contrib_df)
  summary(betareg_local_log_abd)
  
  ## predict models into dataframe
  spp_contrib_df$spp_contrib_pred_freq_betareg <- predict(betareg_freq)
  spp_contrib_df$spp_contrib_pred_log_freq_betareg <- predict(betareg_log_freq)
  spp_contrib_df$spp_contrib_pred_logabd_betareg <- predict(betareg_logabd)
  spp_contrib_df$spp_contrib_pred_meanloc_log_abd_betareg <- predict(betareg_local_log_abd)
  
  #### (F.2) contribution vs. niche specialization ####
  ### (F.2.1) contribution vs. niche breadth
  ## reduce dataframe because of NA
  spp_contrib_df_NBmean <- spp_contrib_df %>% 
    filter(!is.na(NBmean))
  


### fit beta regression model for unimodal data
## (F2.1.1) Fit quadratic beta regression
# betareg_NBmean <- betareg(spp_contrib ~ poly(NBmean, 2), data = spp_contrib_df_NBmean)
# summary(betareg_NBmean)
# # predict models into dataframe
# spp_contrib_df_NBmean$spp_contrib_pred_NBmean_betareg <- predict(betareg_NBmean)
# # Plot
# ggplot(spp_contrib_df_NBmean, aes(NBmean, spp_contrib)) +
#   geom_point() +
#   geom_line(aes(y = spp_contrib_pred_NBmean_betareg), color = "blue") +
#   theme_minimal() +
#   ggtitle("")


## (F2.1.2) with raw quadratic terms
# see https://stats.stackexchange.com/questions/258307/raw-or-orthogonal-polynomial-regression

# Fit quadratic beta regression
betareg_NBmean <- betareg(spp_contrib ~ NBmean + I(NBmean^2), data = spp_contrib_df_NBmean)
summary(betareg_NBmean)
# predict models into dataframe
spp_contrib_df_NBmean$spp_contrib_pred_NBmean_betareg <- predict(betareg_NBmean)

  
  spp_contrib_df_NBmean <- spp_contrib_df_NBmean %>%
    dplyr::select(Species, spp_contrib_pred_NBmean_betareg)
  
  spp_contrib_df <- spp_contrib_df %>% left_join(., spp_contrib_df_NBmean, by = "Species")
  
  
  #### (G.) Plotting ####
  
  ### log-frequency
  # get p-value for estimate from betareg output
  pval <- formatC(summary(betareg_log_freq)$coefficients$mean[, 4][2], format = "e", digits = 2)
  
  a <- ggplot(spp_contrib_df, aes(x = log_frequency, y = spp_contrib)) +
     geom_point(aes(color = "Observed"), size = 1.5) +        # Scatter plot of the data
     geom_line(aes(y = spp_contrib_pred_log_freq_betareg, color = "Regression model"), size = 0.7) +  # betareg model
     labs(
       title = "",
       x = "Log-transformed \n frequency of occurrence",
       y = "Species contribution to \n variance explained",
       color = ""
     ) +
     theme_minimal() + 
     scale_color_manual(values = c("Observed" = "grey", "Regression model" = "blue")) +
     theme(legend.position = "top") + 
     ylim(0,0.045) + xlim(0,4) +
     annotate("text", x = 0.2, y = 0.042, label = paste("Pseudo R² =", round(betareg_log_freq$pseudo.r.squared, 3)), 
              size = 3, hjust = 0)

  
  
  if (unname(summary(betareg_log_freq)$coefficients$mean[, 4][2]) < 0.001) {
    (a <- a +
      annotate("text", x = 0.2, y = 0.038, label = expression(italic(p) < 0.001), size = 3, hjust = 0))
  } else {
    (a <- a +
      annotate("text", x = 0.2, y = 0.038, label = bquote(italic("p") == .(pval)), size = 3, hjust = 0))
  }
  
  
  if (h == "understory") {
    a <- a +
      theme(axis.text.x = element_blank()) +
      labs(x = "")
  }
  
  
  ### Log-abundance
  # get p-value for estimate from betareg output
  pval <- formatC(summary(betareg_logabd)$coefficients$mean[, 4][2], format = "e", digits = 2)
  
  b <- ggplot(spp_contrib_df, aes(x = log_abd, y = spp_contrib)) +
      geom_point(aes(color = "Observed"), size = 1.5) +        # Scatter plot of the data
      geom_line(aes(y = spp_contrib_pred_logabd_betareg, color = "Regression model"), size = 0.7) +  # betareg model
      labs(
        title = "",
        x = "Log-transformed \n regional species abundance",
        y = "Species contribution to \n variance explained",
        color = ""
      ) +
      theme_minimal() + 
      scale_color_manual(values = c("Observed" = "grey", "Regression model" = "red")) +
      theme(legend.position = "top") +
      ylim(0,0.045) + xlim(0,6.5) +
      theme(axis.text.y = element_blank()) + labs(y = "") +
      annotate("text", x = 0.5, y = 0.042, label = paste("Pseudo R² =", round(betareg_logabd$pseudo.r.squared, 3)), 
               size = 3, hjust = 0)
  
  
  
  if (unname(summary(betareg_logabd)$coefficients$mean[, 4][2]) < 0.001) {
    (b <- b +
      annotate("text", x = 0.5, y = 0.038, label = expression(italic(p) < 0.001), size = 3, hjust = 0))
  } else {
    (b <- b +
      annotate("text", x = 0.5, y = 0.038, label = bquote(italic("p") == .(pval)), size = 3, hjust = 0))
  }
  
  if (h == "understory") {
    b <- b +
      theme(axis.text.x = element_blank()) +
      labs(x = "")
  }
  
  ### log-transformed mean local abundance
  # get p-value for estimate from betareg output
  pval <- formatC(summary(betareg_local_log_abd)$coefficients$mean[, 4][2], format = "e", digits = 2)
  
  c <- ggplot(spp_contrib_df, aes(x = mean_local_log_abd, y = spp_contrib)) +
      geom_point(aes(color = "Observed"), size = 1.5) +        # Scatter plot of the data
      geom_line(aes(y = spp_contrib_pred_meanloc_log_abd_betareg, color = "Regression model"), size = 0.7) +  # betareg model
      labs(
        title = "",
        x = "Log-transformed \n local species abundance",
        y = "Species contribution to \n variance explained",
        color = ""
      ) +
      theme_minimal() + 
      ylim(0,0.045) + xlim(0,5) +
      scale_color_manual(values = c("Observed" = "grey", "Regression model" = "green")) +
      theme(legend.position = "top") +
      theme(axis.text.y = element_blank()) + labs(y = "") + 
      annotate("text", x = 0.2, y = 0.042, label = paste("Pseudo R² =", round(betareg_local_log_abd$pseudo.r.squared, 3)), size = 3, hjust = 0)
  
  
  if (unname(summary(betareg_local_log_abd)$coefficients$mean[, 4][2]) < 0.001) {
    (c <- c +
      annotate("text", x = 0.2, y = 0.038, label = expression(italic(p) < 0.001), size = 3, hjust = 0))
  } else {
    (c <- c +
      annotate("text", x = 0.2, y = 0.038, label = bquote(italic("p") == .(pval)), size = 3, hjust = 0))
  }
  
  if (h == "understory") {
    c <- c +
      theme(axis.text.x = element_blank()) +
      labs(x = "")
  }
  
  
  ### Contribution vs mean global niche breadth
  # get p-value for estimate from betareg output
  pval <- formatC(summary(betareg_NBmean)$coefficients$mean[, 4][2], format = "e", digits = 2)
  
  d <- ggplot(spp_contrib_df, aes(x = NBmean, y = spp_contrib)) +
      geom_point(aes(color = "Observed"), size = 1.5) +        # Scatter plot of the data
      geom_line(aes(y = spp_contrib_pred_NBmean_betareg, color = "Regression model"), size = 0.7) +  # betareg model
      labs(
        title = "",
        x = "Mean global \n niche breadth",
        y = "Species contribution to \n variance explained",
        color = ""
      ) +
      theme_minimal() + 
      ylim(0,0.045) + xlim(0,3) +
      scale_color_manual(values = c("Observed" = "grey", "Regression model" = "black")) +
      theme(legend.position = "top") +
      theme(axis.text.y = element_blank()) +
      labs(y = "")  + 
      annotate("text", x = 0.25, y = 0.042, label = paste("Pseudo R² =", round(betareg_NBmean$pseudo.r.squared, 3)), 
               size = 3, hjust = 0)
  
  if (unname(summary(betareg_NBmean)$coefficients$mean[, 4][2]) < 0.001) {
    (d <- d +
      annotate("text", x = 0.25, y = 0.038, label = expression(italic(p) < 0.001), size = 3, hjust = 0))
  } else {
    (d <- d +
      annotate("text", x = 0.25, y = 0.038, label = bquote(italic("p") == .(pval)), size = 3, hjust = 0))
  }
  
  
  if (h == "understory") {
    d <- d +
      theme(axis.text.x = element_blank()) +
      labs(x = "")
  }
  
  

  
  plot_list[[h]][[1]] <- a
  plot_list[[h]][[2]] <- b
  plot_list[[h]][[3]] <- c
  plot_list[[h]][[4]] <- d
  
} # end loop


## plot species contribution vs commonness
(composite_figure <- print(ggpubr::ggarrange(plot_list[[1]][[1]],plot_list[[1]][[2]],plot_list[[1]][[3]],plot_list[[1]][[4]], plot_list[[2]][[1]],plot_list[[2]][[2]],plot_list[[2]][[3]],plot_list[[2]][[4]], ncol = 4, nrow = 2, common.legend = TRUE)) +
    annotation_custom(grob = textGrob("Understory", gp = gpar(fontsize = 12, fontface = "bold")), 
                      xmin = 0.08, xmax = 0.1, ymin = 0.91, ymax = 0.91) +
    annotation_custom(grob = textGrob("Canopy", gp = gpar(fontsize = 12, fontface = "bold")), 
                      xmin = 0.07, xmax = 0.1, ymin = 0.44, ymax = 0.44))

```

```{r MSR-based nullmodels, echo=FALSE}
### This chunk creates nullmodels by permuting rows (sites) and keeping columns (species) constant.

#### set parameters ####
include_mem <- FALSE # exclude spatial predictors in our null models because they inflate the adjR2
include_varpart <- TRUE

# set Box-Cox parameters
bcc_exp_list <- list(0, 0.25, 0.5, 1)
method <- "rda"
nullmod_nperm <- 999

env_rda <- env_bc
# env_soil <- env_rda %>% dplyr::select(intersect(soil, names(env_rda))) # soil only
env_clim <- env_rda %>% dplyr::select(intersect(climate_vars, names(env_rda))) # climate
# env_topo <- env_rda %>% dplyr::select(intersect(topo_vars, names(env_rda))) # topography only
env_soil <- env_rda %>% dplyr::select(intersect(topo_vars, names(env_rda))|intersect(soil_vars, names(env_rda))) # soil & topo
env_human <- env_rda %>% dplyr::select(intersect(human_vars, names(env_rda))) # human only
  
  
  
### Moran Spectral Randomization
# get coordinates
xy <- coord %>%
    rename(x = "ddlon") %>%
    rename(y = "ddlat")
  
  
## spatial weighting matrix for MSR-generated null models
# create gabriel's grab spatial environment
library(spdep)
nbgab <- spdep::graph2nb(spdep::gabrielneigh(as.matrix(xy[,1:2])), sym = TRUE)
# plot spatial environment
g1 <- s.label(as.matrix(xy[,1:2]), nb = nbgab, pnb.edge.col = "red", main = "Gabriel", plot = FALSE)
ADEgS(list(g1)) # plot gabriel's graph network
  
## Calculation of the Spatial Weighting Matrix (SWM)
swm <- spdep::nb2listw(nbgab, style = "B")
  


# Chose spatial weighting matrix
mem_candidates <- listw.candidates(
  coord, # list of point coordinates
  nb = c("mst", "gab"), # test for minimum spanning tree (mst) and Gabriel's graph (gab)
  weights = c("binary", "flin")) # test for neutral and linear weighting matrices


# selection of MEMs once at the start of the script for each stratum & resolution
gbmem_list <- list(understory = list(), canopy = list())

for (i in 1:length(community_data)) {
  
  ## strict species
  cdm <- community_data[[i]] %>% 
    filter(!is.na(tax_esp)) %>% 
    group_by(plot_name, tax_tax) %>% 
    count() %>% 
    reshape::cast(., plot_name ~ tax_tax, value='n') %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    column_to_rownames(., var = "plot_name")
  
  # Select Spatial weighting matrix (SWM)
  mem_select <- adespatial::listw.select(cdm,
                                         mem_candidates,
                                         method = "FWD",
                                         MEM.autocor = "positive",
                                         nperm = nullmod_nperm, # reduced to reduce computational time
                                         nperm.global = nullmod_nperm) # run forward selection
  
  # test results of global model test
  mem_select$best$global.test
  # Summary of listw.select
  mem_select$best$summary
  # capture MEMs of listw.select in dataframe
  gbmem_list[[i]][["strict_sp"]] <- as.data.frame(mem_select$best$MEM.select)
  
  
  ## morpho taxa
  cdm <- community_data[[i]] %>% 
    # left_join(., morpho_spp, by = "tax_tax") %>% 
    group_by(plot_name, tax_morpho2) %>% 
    count() %>% 
    reshape::cast(., plot_name ~ tax_morpho2, value='n') %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    column_to_rownames(., var = "plot_name")
  
  # Select Spatial weighting matrix (SWM)
  mem_select <- adespatial::listw.select(cdm,
                                         mem_candidates,
                                         method = "FWD",
                                         MEM.autocor = "positive",
                                         nperm = nullmod_nperm, # reduced to reduce computational time
                                         nperm.global = nullmod_nperm) # run forward selection
  
  # test results of global model test
  mem_select$best$global.test
  # Summary of listw.select
  mem_select$best$summary
  # capture MEMs of listw.select in dataframe
  gbmem_list[[i]][["morpho_sp"]] <- as.data.frame(mem_select$best$MEM.select)
  
  ## genus
  cdm <- community_data[[i]] %>% 
    filter(!is.na(tax_gen)) %>% 
    group_by(plot_name, tax_gen) %>% 
    count() %>% 
    reshape::cast(., plot_name ~ tax_gen, value='n') %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    column_to_rownames(., var = "plot_name")
  
  # Select Spatial weighting matrix (SWM)
  mem_select <- adespatial::listw.select(cdm,
                                         mem_candidates,
                                         method = "FWD",
                                         MEM.autocor = "positive",
                                         nperm = nullmod_nperm, # reduced to reduce computational time
                                         nperm.global = nullmod_nperm) # run forward selection
  
  # test results of global model test
  mem_select$best$global.test
  # Summary of listw.select
  mem_select$best$summary
  # capture MEMs of listw.select in dataframe
  gbmem_list[[i]][["genus"]] <- as.data.frame(mem_select$best$MEM.select)
  
  
  ## family
  cdm <- community_data[[i]] %>% 
    filter(!is.na(tax_fam)) %>% 
    group_by(plot_name, tax_fam) %>% 
    count() %>% 
    reshape::cast(., plot_name ~ tax_fam, value='n') %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    column_to_rownames(., var = "plot_name")
  
  # Select Spatial weighting matrix (SWM)
  mem_select <- adespatial::listw.select(cdm,
                                         mem_candidates,
                                         method = "FWD",
                                         MEM.autocor = "positive",
                                         nperm = nullmod_nperm, # reduced to reduce computational time
                                         nperm.global = nullmod_nperm) # run forward selection
  
  # test results of global model test
  mem_select$best$global.test
  # Summary of listw.select
  mem_select$best$summary
  # capture MEMs of listw.select in dataframe
  gbmem_list[[i]][["family"]] <- as.data.frame(mem_select$best$MEM.select)
}
  
  
# base list to capture global and partial R2s
if (include_varpart & !include_mem) {
    lst <- list(global = list(), soil = list(), climate = list(), human = list(), soil_pure = list(), climate_pure = list(), human_pure = list())
  } else if (include_varpart & include_mem) {
    lst <- list(global = list(), soil = list(), climate = list(), human = list(), soil_pure = list(), climate_pure = list(), human_pure = list(), spatial_pure = list())
  } else if (!include_varpart) {
    lst <- list(global = list())
  }
  
# nested list structure to loop over strata and resolutions
nullmod_list <- list(understory = list(strict_sp = list(), morpho_sp = list(), genus = list(), family = list()), 
                     canopy = list(strict_sp = list(),morpho_sp = list(), genus = list(), family = list()))
  
  
  for (k in c("understory", "canopy")){
    for (l in c("strict_sp", "morpho_sp", "genus", "family")) {
      
      ## select set of spatial predictors, if applicable
      if (include_mem) {
        gbmem <- gbmem_list[[k]][[l]]
        env_bc_mem <- cbind(env_bc, gbmem)
      } else {
        env_bc_mem <- env_bc
      }
      
      
      ## run permutations of env+spat predictors
      env_rda_msr  <- adespatial::msr(env_bc_mem, swm, nrepet = nullmod_nperm, method = "singleton")

      
      ## assemble community data and identify optimum Box-Cox-Chord transformations based on maximum R2 (Borcard & Legendre)
      if(l == "strict_sp"){
        cdm <- community_data[[k]] %>%
          filter(!is.na(tax_esp)) %>% # discard NA entries
          group_by(plot_name) %>%
          count(tax_sp_level) %>%
          reshape::cast(.,
                        plot_name ~ tax_sp_level,
                        value='n') %>%
          mutate_all(~replace(., is.na(.), 0)) %>%
          column_to_rownames(., var = "plot_name") %>% 
          dplyr::select(-any_of("V1")) 

        
        ## calcualte optimum BCC for original data and keep throughout subsequent loops
        # run RDA and VP
        cdm_bcc_list <- list()
        rda_r2_list <- list()
        
        ## find optimal BCC transformation coefficient by identifying the highest R2ajd for global RDA
        for (j in 1:length(bcc_exp_list)) {
          
          cdm_bcc_list[[j]] <- box.cox.chord(cdm, bc.exp = bcc_exp_list[[j]])
          rda_temp <- vegan::rda(cdm_bcc_list[[j]] ~ ., as.data.frame(env_rda_msr[[i]]), na=na.omit, subset = complete.cases(cdm), scale=FALSE)
          rda_r2_list[[j]] <- RsquareAdj(rda_temp)$adj.r.squared
          rm(rda_temp)
        }
        
        # get community data matrix with transformed frequencies
        cdm_bcc <- cdm_bcc_list[[which.max(unlist(rda_r2_list))]]
        
        
      } else if (l == "morpho_sp") {
        cdm <- community_data[[k]] %>%
          filter(!is.na(tax_morpho2)) %>% # discard NA entries
          group_by(plot_name) %>%
          count(tax_morpho2) %>%
          reshape::cast(.,
                        plot_name ~ tax_morpho2,
                        value='n') %>%
          mutate_all(~replace(., is.na(.), 0)) %>%
          column_to_rownames(., var = "plot_name") %>% 
                    dplyr::select(-any_of("V1"))
        
        ## calcualte optimum BCC for original data and keep throughout subsequent loops
        # run RDA and VP
        cdm_bcc_list <- list()
        rda_r2_list <- list()
        
        ## find optimal BCC transformation coefficient by identifying the highest R2ajd for global RDA
        for (j in 1:length(bcc_exp_list)) {
          
          cdm_bcc_list[[j]] <- box.cox.chord(cdm, bc.exp = bcc_exp_list[[j]])
          rda_temp <- vegan::rda(cdm_bcc_list[[j]] ~ ., as.data.frame(env_rda_msr[[i]]), na=na.omit, subset = complete.cases(cdm), scale=FALSE)
          rda_r2_list[[j]] <- RsquareAdj(rda_temp)$adj.r.squared
          rm(rda_temp)
        }
        
        # get community data matrix with transformed frequencies
        cdm_bcc <- cdm_bcc_list[[which.max(unlist(rda_r2_list))]]
        
      } else if (l == "genus") {
        cdm <- community_data[[k]] %>% # morpho taxa
          filter(!is.na(tax_gen)) %>% # discard NA entries
          group_by(plot_name) %>%
          count(tax_gen) %>%
          reshape::cast(.,
                        plot_name ~ tax_gen,
                        value='n') %>%
          mutate_all(~replace(., is.na(.), 0)) %>%
          column_to_rownames(., var = "plot_name") %>% 
          dplyr::select(-any_of("V1")) 
        
        ## calcualte optimum BCC for original data and keep throughout subsequent loops
        # run RDA and VP
        cdm_bcc_list <- list()
        rda_r2_list <- list()
        
        ## find optimal BCC transformation coefficient by identifying the highest R2ajd for global RDA
        for (j in 1:length(bcc_exp_list)) {
          
          cdm_bcc_list[[j]] <- box.cox.chord(cdm, bc.exp = bcc_exp_list[[j]])
          rda_temp <- vegan::rda(cdm_bcc_list[[j]] ~ ., as.data.frame(env_rda_msr[[i]]), na=na.omit, subset = complete.cases(cdm), scale=FALSE)
          rda_r2_list[[j]] <- RsquareAdj(rda_temp)$adj.r.squared
          rm(rda_temp)
        }
        
        # get community data matrix with transformed frequencies
        cdm_bcc <- cdm_bcc_list[[which.max(unlist(rda_r2_list))]]
        
      } else if (l == "family") {
        cdm <- community_data[[k]] %>% # morpho taxa
          filter(!is.na(tax_fam)) %>% # discard NA entries
          group_by(plot_name) %>%
          count(tax_fam) %>%
          reshape::cast(.,
                        plot_name ~ tax_fam,
                        value='n') %>%
          mutate_all(~replace(., is.na(.), 0)) %>%
          column_to_rownames(., var = "plot_name") %>% 
          dplyr::select(-any_of("V1")) 
        
        ## calcualte optimum BCC for original data and keep throughout subsequent loops
        # run RDA and VP
        cdm_bcc_list <- list()
        rda_r2_list <- list()
        
        ## find optimal BCC transformation coefficient by identifying the highest R2ajd for global RDA
        for (j in 1:length(bcc_exp_list)) {
          
          cdm_bcc_list[[j]] <- box.cox.chord(cdm, bc.exp = bcc_exp_list[[j]])
          rda_temp <- vegan::rda(cdm_bcc_list[[j]] ~ ., as.data.frame(env_rda_msr[[i]]), na=na.omit, subset = complete.cases(cdm), scale=FALSE)
          rda_r2_list[[j]] <- RsquareAdj(rda_temp)$adj.r.squared
          rm(rda_temp)
        }
        
        # get community data matrix with transformed frequencies
        cdm_bcc <- cdm_bcc_list[[which.max(unlist(rda_r2_list))]]
        
      }
      
      
      for (i in 1:nullmod_nperm){
        
        print(paste0("Implementing nullmodels for ", k, " / ", l, ": ", i, " out of ", nullmod_nperm))
        
        ## separate partial predictor classes for each MSR-permuted 'env' dataset
        # env_soil <- env_rda %>% dplyr::select(intersect(soil, names(env_rda))) # soil only
        env_clim_permuted <- as.data.frame(env_rda_msr[[i]]) %>% dplyr::select(intersect(climate_vars, names(env_rda))) # climate
        # env_topo <- env_rda %>% dplyr::select(intersect(topo_vars, names(env_rda))) # topography only
        env_soil_permuted <- as.data.frame(env_rda_msr[[i]]) %>% dplyr::select(intersect(topo_vars, names(env_rda))|intersect(soil_vars, names(env_rda))) # soil & topo
        env_human_permuted <- as.data.frame(env_rda_msr[[i]]) %>% dplyr::select(intersect(human_vars, names(env_rda))) # human only
        
        ## run RDA
        if (method == "rda") {
          ## regular RDA
          glob <- vegan::rda(cdm_bcc ~ ., as.data.frame(env_rda_msr[[i]]), na=na.omit, subset = complete.cases(cdm_bcc),
                             scale=FALSE) # set 'scale = FALSE' if response is CDM 
        } else if (method == "dbrda") {
          ## distance-based RDA
          glob <- vegan::capscale(cdm_bcc ~ ., as.data.frame(env_rda_msr[[i]]), comm = cdm_bcc, na=na.omit) 
          # do not use vegan::dbrda() because it produces negative eigenvectors
        }
        
        # Adjusted R^2 retrieved from the rda object 
        lst[[1]][[i]] <- RsquareAdj(glob)$adj.r.squared
        
        if (include_varpart & !include_mem) {
          varpart <- varpart(cdm_bcc, env_soil_permuted, env_clim_permuted, env_human_permuted)
          
          # global fractions
          lst[[2]][[i]] <- as.data.frame(varpart$part$fract)[1,3] # soil
          lst[[3]][[i]] <- as.data.frame(varpart$part$fract)[2,3] # climate
          lst[[4]][[i]] <- as.data.frame(varpart$part$fract)[3,3] # human
          
          # pure fractions
          lst[[5]][[i]] <- as.data.frame(varpart$part$indfract)[1,3] # soil pure [a]
          lst[[6]][[i]] <- as.data.frame(varpart$part$indfract)[2,3] # climate pure [b]
          lst[[7]][[i]] <- as.data.frame(varpart$part$indfract)[3,3] # human pure [c]
          
        } else if (include_varpart & include_mem) {
          
          varpart <- varpart(cdm_bcc, env_soil_permuted, env_clim_permuted, env_human_permuted, gbmem)
          
          # global fractions
          lst[[2]][[i]] <- as.data.frame(varpart$part$fract)[1,3] # soil
          lst[[3]][[i]] <- as.data.frame(varpart$part$fract)[2,3] # climate
          lst[[4]][[i]] <- as.data.frame(varpart$part$fract)[3,3] # human
          
          # pure fractions
          lst[[5]][[i]] <- as.data.frame(varpart$part$contr2)[3,3] # soil pure [ah]
          lst[[6]][[i]] <- as.data.frame(varpart$part$contr2)[6,3] # climate pure [bi]
          lst[[7]][[i]] <- as.data.frame(varpart$part$contr2)[9,3] # human pure [cj]
          
          lst[[8]][[i]] <- as.data.frame(varpart$part$indfract)[4,3] # space pure [d]

        } # end if statement
        
        
      } # end i loop (nperm)
      
      
      ## get all nperm elements
      nullmod_list[[k]][[l]] <- as.data.frame(unlist(lst)) %>% 
        rename(value = 1) %>% 
        rownames_to_column(var = "fraction") %>% 
        mutate(
        nperm = str_extract(fraction, "\\d+$"),  # Extract the last number/character
        fraction = str_remove(fraction, "\\d+$")  # Remove the last number/character from 'name'
      ) %>% mutate(stratum = k,
               resolution = l)
      
      
    } # end l loop (resolution)
  } # end k loop (stratum)
  
## all nullmodel's R2
nullmod_all <- bind_rows(as.data.frame(bind_rows(nullmod_list[[1]])),as.data.frame(bind_rows(nullmod_list[[2]])))
  
## calculate mean + SD for plots
nullmod <- bind_rows(as.data.frame(bind_rows(nullmod_list[[1]])),as.data.frame(bind_rows(nullmod_list[[2]]))) %>% 
    group_by(stratum, resolution, fraction) %>% 
    summarize(mean = mean(value),
              sd = sd(value))
  
# reorder factor levels
nullmod$resolution <- factor(nullmod$resolution, levels = c("strict_sp", "morpho_sp", "genus", "family"))

```

```{r [main code] R2 decline ~ observer error, echo=FALSE}
### runtime = 7h (nperm = 20; errors = 21 [0 - 1]; varpart & MEM included)
### New main code using 'shuff.cdm2' and 'shuff.cdm_fam2' functions, after the integration of 3 types of rarity (frequency, total abundance and local abundance)
### the final output of this chunk is dataframe 'final.df', which contains all global and partial adjusted R2 values & p values for all strata, shuffling depths, taxonomic resolutions over the error range specified in 'errors'.


#### set parameters for shuff.cdm() ####
# include spatial predictors (MEMs) as explanatory variable class?
include_mem <- TRUE # inflates runtime x2 if TRUE
# include variation partitioning to retrieve partial R2?
include_varpart <- TRUE

nperm <- 25 # nb. of permutations over entire code
nperm_rda <- 999 # for global RDA significance test with anova.cca()
errors <- as.list(c(seq(0, 1, by = 0.05)))
bcc_exp_list <- list(0, 0.25, 0.5, 1)
method <- "rda"
perc_cutoff <- 0.5 # threshold for classification of spp. into "minor" and "major" (in function of 'rarity criterion' applied, see below)
rarity_criterion <- "global_abd" # settings are (i) "global_abd", (ii) "local_abd" or (iii) "frequency"
shuffle_fraction <- "all" # "rare = shuffle rare species (cumsum < cutoff); "common" = shuffle common species (cumsum > cutoff); "all = shuffle all species, regardless of commonness

## explanatory variable dataset
env_rda <- env_bc # use Box-Cox-Chord transformed environmental variables

# create and name nested list
master_list <- replicate(2, list(replicate(length(errors), list())))
names(master_list) <- c("understory", "canopy")
for (i in 1:length(master_list)) {
  names(master_list[[i]]) <- paste0("error_", errors)
}

# create and name nested list for diagnostics
diagnostics_master_list <- replicate(2, list(replicate(length(errors), list())))
names(diagnostics_master_list) <- c("understory", "canopy")
for (i in 1:length(diagnostics_master_list)) {
  names(diagnostics_master_list[[i]]) <- paste0("error_", errors)
}



#### generate spatial predictors ####
if (include_mem & !exists("gbmem_list")) {
  
  # get coordinates and calculate four SWM with listw.candidates()
coord_env <- coord %>% 
  filter(plot_name %in% rownames(env_rda)) %>% 
  column_to_rownames(var = "plot_name") %>% 
  dplyr::select(ddlat, ddlon)

# Chose spatial weighting matrix
mem_candidates <- listw.candidates(
  coord_env, # list of point coordinates
  nb = c("mst", "gab"), # test for minimum spanning tree (mst) and Gabriel's graph (gab)
  weights = c("binary", "flin")) # test for neutral and linear weighting matrices

# selection of MEMs once at the start of the script for each stratum & resolution
gbmem_list <- list(understory = list(), canopy = list())
swm <- as.data.frame(matrix(ncol = 3, nrow = 8)) %>%  # to capture combination of SWM (Bauman et al., 2018)
  setNames(c("dataset", "resolution", "swm")) %>% 
  mutate(dataset = c(rep("understory",4), rep("canopy",4))) %>% 
  mutate(resolution = (rep(c("strict_sp", "morpho_taxon", "genus", "family"),2)))

for (i in 1:length(master_list)) {
  
  ## strict species
  cdm <- community_data[[i]] %>% 
    filter(!is.na(tax_esp)) %>% 
    group_by(plot_name, tax_tax) %>% 
    count() %>% 
    reshape::cast(., plot_name ~ tax_tax, value='n') %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    column_to_rownames(., var = "plot_name")
  
  # Select Spatial weighting matrix (SWM)
  mem_select <- adespatial::listw.select(cdm,
                                         mem_candidates,
                                         method = "FWD",
                                         MEM.autocor = "positive",
                                         nperm = 999, # reduced to reduce computational time
                                         nperm.global = 999) # run forward selection
  
  if (i == 1) {
    swm[1,3] <- row.names(mem_select$candidates)[which.max(mem_select$candidates$R2Adj.select)]
  } else {
    swm[5,3] <- row.names(mem_select$candidates)[which.max(mem_select$candidates$R2Adj.select)]
  }
  
  # test results of global model test
  mem_select$best$global.test
  # Summary of listw.select
  mem_select$best$summary
  # capture MEMs of listw.select in dataframe
  gbmem_list[[i]][["strict_sp"]] <- as.data.frame(mem_select$best$MEM.select)
  
  
  ## morpho taxa
  cdm <- community_data[[i]] %>% 
    # left_join(., morpho_spp, by = "tax_tax") %>% 
    group_by(plot_name, tax_morpho2) %>% 
    count() %>% 
    reshape::cast(., plot_name ~ tax_morpho2, value='n') %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    column_to_rownames(., var = "plot_name")
  
  # Select Spatial weighting matrix (SWM)
  mem_select <- adespatial::listw.select(cdm,
                                         mem_candidates,
                                         method = "FWD",
                                         MEM.autocor = "positive",
                                         nperm = 999, # reduced to reduce computational time
                                         nperm.global = 999) # run forward selection
  
   if (i == 1) {
    swm[2,3] <- row.names(mem_select$candidates)[which.max(mem_select$candidates$R2Adj.select)]
  } else {
    swm[6,3] <- row.names(mem_select$candidates)[which.max(mem_select$candidates$R2Adj.select)]
  }
  
  # test results of global model test
  mem_select$best$global.test
  # Summary of listw.select
  mem_select$best$summary
  # capture MEMs of listw.select in dataframe
  gbmem_list[[i]][["morpho_sp"]] <- as.data.frame(mem_select$best$MEM.select)
  
  ## genus
  cdm <- community_data[[i]] %>% 
    filter(!is.na(tax_gen)) %>% 
    group_by(plot_name, tax_gen) %>% 
    count() %>% 
    reshape::cast(., plot_name ~ tax_gen, value='n') %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    column_to_rownames(., var = "plot_name")
  
  # Select Spatial weighting matrix (SWM)
  mem_select <- adespatial::listw.select(cdm,
                                         mem_candidates,
                                         method = "FWD",
                                         MEM.autocor = "positive",
                                         nperm = 999, # reduced to reduce computational time
                                         nperm.global = 999) # run forward selection
  
  if (i == 1) {
    swm[3,3] <- row.names(mem_select$candidates)[which.max(mem_select$candidates$R2Adj.select)]
  } else {
    swm[7,3] <- row.names(mem_select$candidates)[which.max(mem_select$candidates$R2Adj.select)]
  }
  
  # test results of global model test
  mem_select$best$global.test
  # Summary of listw.select
  mem_select$best$summary
  # capture MEMs of listw.select in dataframe
  gbmem_list[[i]][["genus"]] <- as.data.frame(mem_select$best$MEM.select)
  
  
  ## family
  cdm <- community_data[[i]] %>% 
    filter(!is.na(tax_fam)) %>% 
    group_by(plot_name, tax_fam) %>% 
    count() %>% 
    reshape::cast(., plot_name ~ tax_fam, value='n') %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    column_to_rownames(., var = "plot_name")
  
  # Select Spatial weighting matrix (SWM)
  mem_select <- adespatial::listw.select(cdm,
                                         mem_candidates,
                                         method = "FWD",
                                         MEM.autocor = "positive",
                                         nperm = 999, # reduced to reduce computational time
                                         nperm.global = 999) # run forward selection
  
  if (i == 1) {
    swm[4,3] <- row.names(mem_select$candidates)[which.max(mem_select$candidates$R2Adj.select)]
  } else {
    swm[8,3] <- row.names(mem_select$candidates)[which.max(mem_select$candidates$R2Adj.select)]
  }
  
  
  
  # test results of global model test
  mem_select$best$global.test
  # Summary of listw.select
  mem_select$best$summary
  # capture MEMs of listw.select in dataframe
  gbmem_list[[i]][["family"]] <- as.data.frame(mem_select$best$MEM.select)
}
  
} # end if statement



#### (A.) outer loops - stratum & error ####
tic()
for (i in 1:length(master_list)) { # loop over forest stratum
  for (j in 1:length(errors)){ # loop over errors
    
    # Verbose
    print(paste0("Shuffling '",names(master_list[i]),"' with error rate = ", errors[[j]]))
    
    ## create list in-loop for 3 different shuffling depths to capture R2 in inner main loop
    list_depth <- replicate(3, 
                            data.frame(matrix(NA,nrow = nperm,ncol = 4)) %>% 
                              setNames(c("strict_sp", "morpho_sp", "genus", "family")), 
                            simplify = FALSE)
    
    
    ## list with shuffled community data for 3 levels of depth
    shuffled_list <- list()
    diagnostics_list <- list() #capture 'diagnostics' dataframe
    
    if (errors[[j]] != 0) {
      
      for (depth in 1:3) {
        if (depth == 1) {
          shuff_esp <- shuff.cdm2(community_data[[i]], 
                                 flora = flora, 
                                 nperm = nperm, 
                                 error = errors[[j]], 
                                 prop_tax_gen = 0, 
                                 perc_cutoff = perc_cutoff,
                                 rarity_criterion = rarity_criterion,
                                 shuffle_fraction = shuffle_fraction,
                                 shuffle_aggregated = TRUE, 
                                 shuffle_esp_NA = TRUE)
          shuffled_list[[depth]] <- shuff_esp[[1]]
          diagnostics_list[[depth]] <- shuff_esp[[2]]
          
        } else if (depth == 2) {
          shuff_gen <- shuff.cdm2(community_data[[i]], 
                                 flora = flora, 
                                 nperm = nperm, 
                                 error = errors[[j]], 
                                 prop_tax_gen = 1, 
                                 perc_cutoff = perc_cutoff,
                                 rarity_criterion = rarity_criterion,
                                 shuffle_fraction = shuffle_fraction,
                                 shuffle_aggregated = TRUE, 
                                 shuffle_esp_NA = TRUE)
          shuffled_list[[depth]] <- shuff_gen[[1]]
          diagnostics_list[[depth]] <- shuff_gen[[2]]
        } else {
          shuff_fam <- shuff.cdm_fam2(community_data[[i]], 
                                     flora = flora, 
                                     nperm = nperm, 
                                     error = errors[[j]],
                                     perc_cutoff = perc_cutoff,
                                     rarity_criterion = rarity_criterion,
                                     shuffle_fraction = shuffle_fraction,
                                     shuffle_aggregated = TRUE, 
                                     shuffle_esp_NA = TRUE)
          shuffled_list[[depth]] <- shuff_fam[[1]]
          diagnostics_list[[depth]] <- shuff_fam[[2]]
        }
      }
      
    } else {
      
      ### in the case 'error = 0', identifications are not reshuffled, therefore, we paste the original dataset for 'shuff_esp', 'shuff_gen' and 'shuff_fam'
      
      commdata_zero_error <- community_data[[i]] %>% 
        dplyr::select(plot_name, tax_fam, tax_gen, tax_esp, tax_tax) %>% 
        group_by(plot_name) %>% 
        mutate(new_transect_id = cur_group_id()) # set ID with group_by
      
      # species level
      
      # Create an empty list to hold the repeated dataframes
      list_d <- lapply(1:nperm, function(i) commdata_zero_error)
      # Name the elements of the list
      names(list_d) <- paste0("nperm_", 1:nperm)
      
      ## feed into 'shuffled_list'
      # species level
      shuffled_list[[1]] <- list_d
      diagnostics_list[[1]] <- NA
      # genus level
      shuffled_list[[2]] <- list_d
      diagnostics_list[[2]] <- NA
      # family level
      shuffled_list[[3]] <- list_d
      diagnostics_list[[3]] <- NA
      
    } # end else statement
    
    
    # name 'shuffled_list' element
    if (length(shuffled_list)!=0) {
      names(shuffled_list) <- c("depth_esp", "depth_gen", "depth_fam")
      names(diagnostics_list) <- c("depth_esp", "depth_gen", "depth_fam")
    }
    
    
    ## unlist diagnostics to dataframe
    # second if statement is to exclude 'error = 0' settings, for which all list elements of 'diagnostics_list' are NA
    if (errors[[j]] != 0) {
      
      if (length(diagnostics_list)!=0) {
        diagnostics.df_list <- list()
        
        for (p in 1:length(diagnostics_list)) {
          diagnostics.df_list[[p]] <- bind_rows(diagnostics_list[[p]], .id = "permutation") %>% 
            mutate(stratum = names(diagnostics_list[p]))
        }
        names(diagnostics.df_list) <- c("depth_esp", "depth_gen", "depth_fam")
        
        diagnostics.df <- bind_rows(diagnostics.df_list) %>% 
          rename(depth = "stratum") %>% 
          mutate(error = errors[[j]]) %>%  # remove string from cells
          mutate(stratum = names(master_list[i]))
        rm(diagnostics.df_list)
      }
    } else {
      diagnostics.df <- NA
    }
    
    
    
    #### (B.) Inner loops - fit RDAs over shuffling depth and nperm ####
    # this loop iterates over three shuffling depths (tax_esp, tax_gen & tax_fam), as implemented via the 'shuff.cdm' function
    
    ## If statement 1: implement RDAs only if shuffled_list is not empty
    if (length(shuffled_list)!=0) {
      
      # Set up parallel backend (adjust number of cores as necessary)
      numCores <- parallel::detectCores() - 3
      cl <- parallel::makeCluster(numCores)
      doParallel::registerDoParallel(cl)
      
      tic()
      
      
      # Use foreach for the outer loop over k
      list_depth <- foreach(k = 1:length(shuffled_list), .packages = c("dplyr", "tidyr", "tibble", "vegan", "reshape", "adespatial")) %dopar% {
        
        
        # Initialize a dataframe to store results for this k (ncol = n)
        list_k <- as.data.frame(matrix(NA, nperm, 4)) %>% 
          setNames(c("strict_sp", "morpho_sp", "genus", "family")) 
        
        # create adapted list_k objects in function of parameter choice
        if (include_varpart & include_mem) {
          list_k <- list(list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k) # create nested list to capture (1) adjR2 and (2) pval
          names(list_k) <- c("adjR2", "pval", "adjR2_soil", "adjR2_climate", "adjR2_human", "adjR2_soil_pure", "adjR2_climate_pure", "adjR2_human_pure", "pval_soil", "pval_climate", "pval_human", "pval_soil_pure", "pval_climate_pure", "pval_human_pure", "adjR2_space_pure", "pval_space_pure")
        } else if (include_varpart & !include_mem) {
          list_k <- list(list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k, list_k) # create nested list to capture (1) adjR2 and (2) pval
          names(list_k) <- c("adjR2", "pval", "adjR2_soil", "adjR2_climate", "adjR2_human", "adjR2_soil_pure", "adjR2_climate_pure", "adjR2_human_pure", "pval_soil", "pval_climate", "pval_human", "pval_soil_pure", "pval_climate_pure", "pval_human_pure")
        } else if (include_varpart == FALSE & include_mem) {
          list_k <- list(list_k, list_k) # create nested list to capture (1) adjR2 and (2) pval
          names(list_k) <- c("adjR2", "pval")
        } else if (include_varpart == FALSE & include_mem == FALSE) {
          list_k <- list(list_k, list_k) # create nested list to capture (1) adjR2 and (2) pval
          names(list_k) <- c("adjR2", "pval")
        }
        
        
        
        ## If statement 2: in case only some [and not all] shuffled_list elements are empty, implement RDAs only for non-empty
        if (!is.null(shuffled_list[[k]])) {
          
          for (m in 1:nperm) { # open nperm loop (nperm)
            
            print(paste0("Nperm loop with m = ", m, " for k = ", k, ", i = ", i, " and j = ", j))
            
            #### (B.1)  strict species-level approach ####
            cdm <- shuffled_list[[k]][[m]] %>% 
              filter(!is.na(tax_esp)) %>% 
              group_by(plot_name, tax_tax) %>% 
              count() %>% 
              reshape::cast(., plot_name ~ tax_tax, value='n') %>%
              mutate_all(~replace(., is.na(.), 0)) %>%
              column_to_rownames(., var = "plot_name")
            
            
            # add MEMs to environmental predictor dataframe (if applicable)
            if (include_mem) {
              gbmem <- gbmem_list[[i]][[1]]
              env_bc_mem <- cbind(env_bc, gbmem)
            } else {
              env_bc_mem <- env_bc
            }
            
            ## synchronize cdm with env_bc_mem [18 Feb 2025]
            env_bc_mem <- env_bc_mem %>% 
              rownames_to_column(var = "plot_name") %>% 
              filter(plot_name %in% rownames(cdm)) %>% 
              column_to_rownames(var = "plot_name")
            
            ## create subsets of environmental predictors
            env_clim_sel <- env_bc_mem %>% dplyr::select(any_of(climate_vars)) # climate
            env_soil_sel <- env_bc_mem %>% dplyr::select(any_of(c(soil_vars, topo_vars))) # soil & topo
            env_human_sel <- env_bc_mem %>% dplyr::select(intersect(human_vars, names(env_rda))) # human only
            env_space_sel <- env_bc_mem %>% dplyr::select(starts_with("MEM")) # human only
            
            # Loop through BCC exponents and calculate RDA
            rda_results <- sapply(bcc_exp_list, function(bcc) {
              cdm_bcc <- box.cox.chord(cdm, bc.exp = bcc)
              
              # Fit RDA or CAP scale model
              if (method == "rda") {
                rda_temp <- vegan::rda(cdm_bcc ~ ., env_bc_mem, na.action = na.omit)
              } else {
                rda_temp <- vegan::capscale(cdm_bcc ~ ., env_bc_mem, comm = cdm_bcc, na.action = na.omit)
              }
              
              # Calculate adjusted R-squared
              adj_r2 <- RsquareAdj(rda_temp)$adj.r.squared
              
              # Perform ANOVA to get p-value
              # anova_results <- anova.cca(rda_temp, permutations = nperm_rda)
              # p_value <- anova_results$`Pr(>F)`[1]  # Get p-value
              
              ## get MSR-based manual p-value
              # (1) get corresponding nullmodels
              adjR2_nullmod <- nullmod_all %>% 
                filter(fraction == "global" &
                         stratum == names(master_list)[[i]] &
                         resolution == "strict_sp")
              # (2) plot histogram
              # ggplot(adjR2_nullmod, aes(x = value)) + 
              #   geom_histogram(color = "black", fill = "lightgrey") +
              #   xlim(0,0.20) +
              #   geom_vline(xintercept = adj_r2, color = "red", linetype = "dashed") +
              #   theme_minimal()
              
              # (3) calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
              p_value = sum(adjR2_nullmod$value >= adj_r2, na.rm=T) / sum(!is.na(adjR2_nullmod$value))
              
              if (include_varpart) {
                if (include_mem) {
                  ### retrieve partial adjR2 values from varpart
                  varpart <- varpart(cdm_bcc, env_soil_sel, env_clim_sel, env_human_sel, env_space_sel)
                  
                  # ## venn diagram
                  # # plot the variation partitioning Venn diagram
                  #                   vegan::showvarparts(4, Xnames = c("Soil & 
                  # Topography", "Climate", "Human", "Space"),
                  #                                       bg = c("seagreen3", "mediumpurple", "red", "yellow"),
                  #                                       alpha = 80)
                  # plot(varpart,
                  #      Xnames = c("Soil", "Climate", "Human", "Space"), # name the partitions
                  #      bg = c("seagreen3", "mediumpurple", "red", "yellow"), alpha = 80, # colour the circles
                  #      digits = 3, # only show 2 digits
                  #      cex = 0.6)
                  
                  adj_r2_soil <- as.data.frame(varpart$part$fract)[1,3] # soil X1 [aeghklno]
                  adj_r2_climate <- as.data.frame(varpart$part$fract)[2,3] # climate X2 [befiklmo]
                  adj_r2_human <- as.data.frame(varpart$part$fract)[3,3] # human X3 [cfgjlmno]
                  
                  # 'pure' & spatial fractions with the remaining two parceled out
                  adj_r2_soil_pure <- as.data.frame(varpart$part$contr2)[3,3] # soil & soil+space | climate & human [ah]
                  adj_r2_climate_pure <- as.data.frame(varpart$part$contr2)[6,3] # climate & climate+space | soil & human [bi]
                  adj_r2_human_pure <- as.data.frame(varpart$part$contr2)[9,3] # human & human+space | soil & climate [cj]
                  
                  # pure spatial fraction
                  adj_r2_space_pure <- as.data.frame(varpart$part$indfract)[4,3] # spatial predictors pure fraction [d]
                  
                  ## Test of partial fractions
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil_pure" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate_pure" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human_pure" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  ### pval_space cannot be tested with MSR-based nullmodels, use anova.cca instead
                  pval_space_pure <- anova.cca(rda(cdm_bcc, env_space_sel, cbind(env_clim_sel, env_human_sel, env_soil_sel)), permutations = how(nperm = nperm_rda))[1,4]
                  
                  # Return a named vector of results
                  return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human, adj_r2_space_pure = adj_r2_space_pure, pval_soil = pval_soil, pval_climate = pval_climate, pval_human = pval_human, adj_r2_soil_pure = adj_r2_soil_pure, adj_r2_climate_pure = adj_r2_climate_pure, adj_r2_human_pure = adj_r2_human_pure, adj_r2_space_pure = adj_r2_space_pure, pval_soil_pure = pval_soil_pure, pval_climate_pure = pval_climate_pure, pval_human_pure = pval_human_pure, pval_space_pure = pval_space_pure))
                  
                } else {
                  ### retrieve partial adjR2 values from varpart
                  varpart <- varpart(cdm_bcc, env_soil_sel, env_clim_sel, env_human_sel)
                  
                  ## Venn diagram
                  # plot the variation partitioning Venn diagram
                  # vegan::showvarparts(3, Xnames = c("Soil", "Climate", "Human"), 
                  #                     bg = c("seagreen3", "mediumpurple", "red"), 
                  #                     alpha = 80) 
                  # plot(varpart,
                  #      Xnames = c("Soil", "Climate", "Human"), # name the partitions
                  #      bg = c("seagreen3", "mediumpurple", "red"), alpha = 80, # colour the circles
                  #      digits = 3, # only show 2 digits
                  #      cex = 0.6)
                  
                  # global fractions
                  adj_r2_soil <- as.data.frame(varpart$part$fract)[1,3] # soil X1 [adfg]
                  adj_r2_climate <- as.data.frame(varpart$part$fract)[2,3] # climate X2 [bdeg]
                  adj_r2_human <- as.data.frame(varpart$part$fract)[3,3] # human X3 [cefg]
                  
                  # pure fractions
                  adj_r2_soil_pure <- as.data.frame(varpart$part$indfract)[1,3] # soil pure fraction [a]
                  adj_r2_climate_pure <- as.data.frame(varpart$part$indfract)[2,3] # climate pure fraction [b]
                  adj_r2_human_pure <- as.data.frame(varpart$part$indfract)[3,3] # human pure fraction [c]
                  
                  ## Test of partial fractions
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil_pure" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate_pure" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human_pure" & stratum == names(master_list)[[i]] & resolution == "strict_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  
                  # Return a named vector of results
                  return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human, pval_soil = pval_soil, pval_climate = pval_climate, pval_human = pval_human, adj_r2_soil_pure = adj_r2_soil_pure, adj_r2_climate_pure = adj_r2_climate_pure, adj_r2_human_pure = adj_r2_human_pure, pval_soil_pure = pval_soil_pure, pval_climate_pure = pval_climate_pure, pval_human_pure = pval_human_pure))
                }
              } else { # if varpart not desired, return only global R2
                return(c(adj_r2 = adj_r2, p_value = p_value))
              }
            })
            
            # Convert results to a data frame for easier manipulation
            results <- as.data.frame(t(rda_results))
            
            ## this is filled in every possible combination of include_mem & include_varpart
            # Find the maximum adjusted R-squared and corresponding p-value
            list_k[[1]][m, 1] <- results[which.max(results$adj_r2), ]["adj_r2"]
            list_k[[2]][m, 1] <- results[which.max(results$adj_r2), ]["p_value"]
            
            ## this is filled only when include_varpart = TRUE
            if (include_varpart) {
              
              list_k[[3]][m, 1] <- results[which.max(results$adj_r2), ]["adj_r2_soil"]
              list_k[[4]][m, 1] <- results[which.max(results$adj_r2), ]["adj_r2_climate"]
              list_k[[5]][m, 1] <- results[which.max(results$adj_r2), ]["adj_r2_human"]
              
              list_k[[6]][m, 1] <- results[which.max(results$adj_r2), ]["adj_r2_soil_pure"]
              list_k[[7]][m, 1] <- results[which.max(results$adj_r2), ]["adj_r2_climate_pure"]
              list_k[[8]][m, 1] <- results[which.max(results$adj_r2), ]["adj_r2_human_pure"]
              
              list_k[[9]][m, 1] <- results[which.max(results$adj_r2), ]["pval_soil"]
              list_k[[10]][m, 1] <- results[which.max(results$adj_r2), ]["pval_climate"]
              list_k[[11]][m, 1] <- results[which.max(results$adj_r2), ]["pval_human"]
              list_k[[12]][m, 1] <- results[which.max(results$adj_r2), ]["pval_soil_pure"]
              list_k[[13]][m, 1] <- results[which.max(results$adj_r2), ]["pval_climate_pure"]
              list_k[[14]][m, 1] <- results[which.max(results$adj_r2), ]["pval_human_pure"]
              
              # add if/else statement in case that gbmem df has nrow = 0
              if (include_mem) {
                list_k[[15]][m, 1] <- results[which.max(results$adj_r2), ]["adj_r2_space_pure"]
                list_k[[16]][m, 1] <- results[which.max(results$adj_r2), ]["pval_space_pure"]
              } # end include_mem statement
              
            } # end include_varpart statement
            
            
            
            #### (B.2)  morpho-taxon  approach ####
            
            cdm <- shuffled_list[[k]][[m]] %>% 
              left_join(., morpho_spp, by = "tax_tax") %>%
              group_by(plot_name, tax_morpho2) %>% 
              count() %>% 
              reshape::cast(., plot_name ~ tax_morpho2, value='n') %>%
              mutate_all(~replace(., is.na(.), 0)) %>%
              column_to_rownames(., var = "plot_name")
            
            # add MEMs to environmental predictor dataframe (if applicable)
            if (include_mem) {
              gbmem <- gbmem_list[[i]][[2]]
              env_bc_mem <- cbind(env_bc, gbmem)
            } else {
              env_bc_mem <- env_bc
            }
            
            ## synchronize cdm with env_bc_mem [18 Feb 2025]
            env_bc_mem <- env_bc_mem %>% 
              rownames_to_column(var = "plot_name") %>% 
              filter(plot_name %in% rownames(cdm)) %>% 
              column_to_rownames(var = "plot_name")
            
            ## create subsets of environmental predictors
            env_clim_sel <- env_bc_mem %>% dplyr::select(any_of(climate_vars)) # climate
            env_soil_sel <- env_bc_mem %>% dplyr::select(any_of(c(soil_vars, topo_vars))) # soil & topo
            env_human_sel <- env_bc_mem %>% dplyr::select(intersect(human_vars, names(env_rda))) # human only
            env_space_sel <- env_bc_mem %>% dplyr::select(starts_with("MEM")) # human only
            
            
            # Loop through BCC exponents and calculate RDA
            rda_results <- sapply(bcc_exp_list, function(bcc) {
              cdm_bcc <- box.cox.chord(cdm, bc.exp = bcc)
              
              # Fit RDA or CAP scale model
              if (method == "rda") {
                rda_temp <- vegan::rda(cdm_bcc ~ ., env_bc_mem, na.action = na.omit)
              } else {
                rda_temp <- vegan::capscale(cdm_bcc ~ ., env_bc_mem, comm = cdm_bcc, na.action = na.omit)
              }
              
              # Calculate adjusted R-squared
              adj_r2 <- RsquareAdj(rda_temp)$adj.r.squared
              
              # Perform ANOVA to get p-value
              # anova_results <- anova.cca(rda_temp, permutations = nperm_rda)
              # p_value <- anova_results$`Pr(>F)`[1]  # Get p-value
              
              ## get MSR-based manual p-value
              # get corresponding nullmodels
              adjR2_nullmod <- nullmod_all %>% 
                filter(fraction == "global" &
                         stratum == names(master_list)[[i]] &
                         resolution == "morpho_sp")
              # calculate pval = proportion of values equal to or above the observed value (OH July 2024)
              p_value = sum(adjR2_nullmod$value >= adj_r2, na.rm=T) / sum(!is.na(adjR2_nullmod$value))
              
              if (include_varpart) {
                if (include_mem) {
                  ### retrieve partial adjR2 values from varpart
                  varpart <- varpart(cdm_bcc, env_soil_sel, env_clim_sel, env_human_sel, env_space_sel)
                  
                  adj_r2_soil <- as.data.frame(varpart$part$fract)[1,3] # soil X1 [aeghklno]
                  adj_r2_climate <- as.data.frame(varpart$part$fract)[2,3] # climate X2 [befiklmo]
                  adj_r2_human <- as.data.frame(varpart$part$fract)[3,3] # human X3 [cfgjlmno]
                  
                  # 'pure' & spatial fractions with the remaining two parcelled out
                  adj_r2_soil_pure <- as.data.frame(varpart$part$contr2)[3,3] # soil & soil+space | climate & human [ah]
                  adj_r2_climate_pure <- as.data.frame(varpart$part$contr2)[6,3] # climate & climate+space | soil & human [bi]
                  adj_r2_human_pure <- as.data.frame(varpart$part$contr2)[9,3] # human & human+space | soil & climate [cj]
                  
                  # pure spatial fraction
                  adj_r2_space_pure <- as.data.frame(varpart$part$indfract)[4,3] # spatial predictors pure fraction [d]
                  
                  ## Test of partial fractions
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil_pure" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate_pure" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human_pure" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  ###  pval_space cannot be tested with MSR-based nullmodels, use anova.cca instead
                  pval_space_pure <- anova.cca(rda(cdm_bcc, env_space_sel, cbind(env_clim_sel, env_human_sel, env_soil_sel)), permutations = how(nperm = nperm_rda))[1,4]
                  
                  # Return a named vector of results
                  return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human, adj_r2_space_pure = adj_r2_space_pure, pval_soil = pval_soil, pval_climate = pval_climate, pval_human = pval_human, adj_r2_soil_pure = adj_r2_soil_pure, adj_r2_climate_pure = adj_r2_climate_pure, adj_r2_human_pure = adj_r2_human_pure, adj_r2_space_pure = adj_r2_space_pure, pval_soil_pure = pval_soil_pure, pval_climate_pure = pval_climate_pure, pval_human_pure = pval_human_pure, pval_space_pure = pval_space_pure))
                  
                } else {
                  ### retrieve partial adjR2 values from varpart
                  varpart <- varpart(cdm_bcc, env_soil_sel, env_clim_sel, env_human_sel)
                  
                  # global fractions
                  adj_r2_soil <- as.data.frame(varpart$part$fract)[1,3] # soil X1 [adfg]
                  adj_r2_climate <- as.data.frame(varpart$part$fract)[2,3] # climate X2 [bdeg]
                  adj_r2_human <- as.data.frame(varpart$part$fract)[3,3] # human X3 [cefg]
                  
                  # pure fractions
                  adj_r2_soil_pure <- as.data.frame(varpart$part$indfract)[1,3] # soil pure fraction [a]
                  adj_r2_climate_pure <- as.data.frame(varpart$part$indfract)[2,3] # climate pure fraction [b]
                  adj_r2_human_pure <- as.data.frame(varpart$part$indfract)[3,3] # human pure fraction [c]
                  
                  ## Test of partial fractions
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil_pure" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate_pure" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human_pure" & stratum == names(master_list)[[i]] & resolution == "morpho_sp")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  
                  # Return a named vector of results
                  return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human, pval_soil = pval_soil, pval_climate = pval_climate, pval_human = pval_human, adj_r2_soil_pure = adj_r2_soil_pure, adj_r2_climate_pure = adj_r2_climate_pure, adj_r2_human_pure = adj_r2_human_pure, pval_soil_pure = pval_soil_pure, pval_climate_pure = pval_climate_pure, pval_human_pure = pval_human_pure))
                }
              } else { # if varpart not desired, return only global R2
                return(c(adj_r2 = adj_r2, p_value = p_value))
              }
            })
            
            # Convert results to a data frame for easier manipulation
            results <- as.data.frame(t(rda_results))
            
            ## this is filled in every possible combination of include_mem & include_varpart
            # Find the maximum adjusted R-squared and corresponding p-value
            list_k[[1]][m, 2] <- results[which.max(results$adj_r2), ]["adj_r2"]
            list_k[[2]][m, 2] <- results[which.max(results$adj_r2), ]["p_value"]
            
            ## this is filled only when include_varpart = TRUE
            if (include_varpart) {
              
              list_k[[3]][m, 2] <- results[which.max(results$adj_r2), ]["adj_r2_soil"]
              list_k[[4]][m, 2] <- results[which.max(results$adj_r2), ]["adj_r2_climate"]
              list_k[[5]][m, 2] <- results[which.max(results$adj_r2), ]["adj_r2_human"]
              
              list_k[[6]][m, 2] <- results[which.max(results$adj_r2), ]["adj_r2_soil_pure"]
              list_k[[7]][m, 2] <- results[which.max(results$adj_r2), ]["adj_r2_climate_pure"]
              list_k[[8]][m, 2] <- results[which.max(results$adj_r2), ]["adj_r2_human_pure"]
              
              list_k[[9]][m, 2] <- results[which.max(results$adj_r2), ]["pval_soil"]
              list_k[[10]][m, 2] <- results[which.max(results$adj_r2), ]["pval_climate"]
              list_k[[11]][m, 2] <- results[which.max(results$adj_r2), ]["pval_human"]
              list_k[[12]][m, 2] <- results[which.max(results$adj_r2), ]["pval_soil_pure"]
              list_k[[13]][m, 2] <- results[which.max(results$adj_r2), ]["pval_climate_pure"]
              list_k[[14]][m, 2] <- results[which.max(results$adj_r2), ]["pval_human_pure"]
              
              # add if/else statement in case that gbmem df has nrow = 0
              if (include_mem) {
                list_k[[15]][m, 2] <- results[which.max(results$adj_r2), ]["adj_r2_space_pure"]
                list_k[[16]][m, 2] <- results[which.max(results$adj_r2), ]["pval_space_pure"]
              } # end include_mem statement
              
            } # end include_varpart statement
            
            
            #### (B.3)  genus level approach ####
            
            cdm <- shuffled_list[[k]][[m]] %>% 
              filter(!is.na(tax_gen)) %>% 
              group_by(plot_name, tax_gen) %>% 
              count() %>% 
              reshape::cast(., plot_name ~ tax_gen, value='n') %>%
              mutate_all(~replace(., is.na(.), 0)) %>%
              column_to_rownames(., var = "plot_name")
            
            # add MEMs to environmental predictor dataframe (if applicable)
            if (include_mem) {
              gbmem <- gbmem_list[[i]][[3]]
              env_bc_mem <- cbind(env_bc, gbmem)
            } else {
              env_bc_mem <- env_bc
            }
            
            ## synchronize cdm with env_bc_mem [18 Feb 2025]
            env_bc_mem <- env_bc_mem %>% 
              rownames_to_column(var = "plot_name") %>% 
              filter(plot_name %in% rownames(cdm)) %>% 
              column_to_rownames(var = "plot_name")
            
            ## create subsets of environmental predictors
            env_clim_sel <- env_bc_mem %>% dplyr::select(any_of(climate_vars)) # climate
            env_soil_sel <- env_bc_mem %>% dplyr::select(any_of(c(soil_vars, topo_vars))) # soil & topo
            env_human_sel <- env_bc_mem %>% dplyr::select(intersect(human_vars, names(env_rda))) # human only
            env_space_sel <- env_bc_mem %>% dplyr::select(starts_with("MEM")) # human only
            
            
            # Loop through BCC exponents and calculate RDA
            rda_results <- sapply(bcc_exp_list, function(bcc) {
              cdm_bcc <- box.cox.chord(cdm, bc.exp = bcc)
              
              # Fit RDA or CAP scale model
              if (method == "rda") {
                rda_temp <- vegan::rda(cdm_bcc ~ ., env_bc_mem, na.action = na.omit)
              } else {
                rda_temp <- vegan::capscale(cdm_bcc ~ ., env_bc_mem, comm = cdm_bcc, na.action = na.omit)
              }
              
              # Calculate adjusted R-squared
              adj_r2 <- RsquareAdj(rda_temp)$adj.r.squared
              
              # Perform ANOVA to get p-value
              # anova_results <- anova.cca(rda_temp, permutations = nperm_rda)
              # p_value <- anova_results$`Pr(>F)`[1]  # Get p-value
              
              ## get MSR-based manual p-value
              # get corresponding nullmodels
              adjR2_nullmod <- nullmod_all %>% 
                filter(fraction == "global" &
                         stratum == names(master_list)[[i]] &
                         resolution == "genus")
              # calculate pval = proportion of values equal to or above the observed value (OH July 2024)
              p_value = sum(adjR2_nullmod$value >= adj_r2, na.rm=T) / sum(!is.na(adjR2_nullmod$value))
              
              if (include_varpart) {
                if (include_mem) {
                  ### retrieve partial adjR2 values from varpart
                  varpart <- varpart(cdm_bcc, env_soil_sel, env_clim_sel, env_human_sel, env_space_sel)
                  
                  adj_r2_soil <- as.data.frame(varpart$part$fract)[1,3] # soil X1 [aeghklno]
                  adj_r2_climate <- as.data.frame(varpart$part$fract)[2,3] # climate X2 [befiklmo]
                  adj_r2_human <- as.data.frame(varpart$part$fract)[3,3] # human X3 [cfgjlmno]
                  
                  # 'pure' & spatial fractions with the remaining two parcelled out
                  adj_r2_soil_pure <- as.data.frame(varpart$part$contr2)[3,3] # soil & soil+space | climate & human [ah]
                  adj_r2_climate_pure <- as.data.frame(varpart$part$contr2)[6,3] # climate & climate+space | soil & human [bi]
                  adj_r2_human_pure <- as.data.frame(varpart$part$contr2)[9,3] # human & human+space | soil & climate [cj]
                  
                  # pure spatial fraction
                  adj_r2_space_pure <- as.data.frame(varpart$part$indfract)[4,3] # spatial predictors pure fraction [d]
                  
                  ## Test of partial fractions
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil_pure" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate_pure" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human_pure" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  ### pval_space cannot be tested with MSR-based nullmodels, use anova.cca instead
                  pval_space_pure <- anova.cca(rda(cdm_bcc, env_space_sel, cbind(env_clim_sel, env_human_sel, env_soil_sel)), permutations = how(nperm = nperm_rda))[1,4]
                  
                  # Return a named vector of results
                  return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human, adj_r2_space_pure = adj_r2_space_pure, pval_soil = pval_soil, pval_climate = pval_climate, pval_human = pval_human, adj_r2_soil_pure = adj_r2_soil_pure, adj_r2_climate_pure = adj_r2_climate_pure, adj_r2_human_pure = adj_r2_human_pure, adj_r2_space_pure = adj_r2_space_pure, pval_soil_pure = pval_soil_pure, pval_climate_pure = pval_climate_pure, pval_human_pure = pval_human_pure, pval_space_pure = pval_space_pure))
                  
                } else {
                  ### retrieve partial adjR2 values from varpart
                  varpart <- varpart(cdm_bcc, env_soil_sel, env_clim_sel, env_human_sel)
                  
                  ## Venn diagram
                  # plot the variation partitioning Venn diagram
                  # vegan::showvarparts(3, Xnames = c("Soil", "Climate", "Human"), 
                  #                     bg = c("seagreen3", "mediumpurple", "red"), 
                  #                     alpha = 80) 
                  # plot(varpart,
                  #      Xnames = c("Soil", "Climate", "Human"), # name the partitions
                  #      bg = c("seagreen3", "mediumpurple", "red"), alpha = 80, # colour the circles
                  #      digits = 3, # only show 2 digits
                  #      cex = 0.6)
                  
                  # global fractions
                  adj_r2_soil <- as.data.frame(varpart$part$fract)[1,3] # soil X1 [adfg]
                  adj_r2_climate <- as.data.frame(varpart$part$fract)[2,3] # climate X2 [bdeg]
                  adj_r2_human <- as.data.frame(varpart$part$fract)[3,3] # human X3 [cefg]
                  
                  # pure fractions
                  adj_r2_soil_pure <- as.data.frame(varpart$part$indfract)[1,3] # soil pure fraction [a]
                  adj_r2_climate_pure <- as.data.frame(varpart$part$indfract)[2,3] # climate pure fraction [b]
                  adj_r2_human_pure <- as.data.frame(varpart$part$indfract)[3,3] # human pure fraction [c]
                  
                  ## Test of partial fractions
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil_pure" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate_pure" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human_pure" & stratum == names(master_list)[[i]] & resolution == "genus")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  
                  # Return a named vector of results
                  return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human, pval_soil = pval_soil, pval_climate = pval_climate, pval_human = pval_human, adj_r2_soil_pure = adj_r2_soil_pure, adj_r2_climate_pure = adj_r2_climate_pure, adj_r2_human_pure = adj_r2_human_pure, pval_soil_pure = pval_soil_pure, pval_climate_pure = pval_climate_pure, pval_human_pure = pval_human_pure))
                }
              } else { # if varpart not desired, return only global R2
                return(c(adj_r2 = adj_r2, p_value = p_value))
              }
            })
            
            # Convert results to a data frame for easier manipulation
            results <- as.data.frame(t(rda_results))
            
            ## this is filled in every possible combination of include_mem & include_varpart
            # Find the maximum adjusted R-squared and corresponding p-value
            list_k[[1]][m, 3] <- results[which.max(results$adj_r2), ]["adj_r2"]
            list_k[[2]][m, 3] <- results[which.max(results$adj_r2), ]["p_value"]
            
            ## this is filled only when include_varpart = TRUE
            if (include_varpart) {
              
              list_k[[3]][m, 3] <- results[which.max(results$adj_r2), ]["adj_r2_soil"]
              list_k[[4]][m, 3] <- results[which.max(results$adj_r2), ]["adj_r2_climate"]
              list_k[[5]][m, 3] <- results[which.max(results$adj_r2), ]["adj_r2_human"]
              
              list_k[[6]][m, 3] <- results[which.max(results$adj_r2), ]["adj_r2_soil_pure"]
              list_k[[7]][m, 3] <- results[which.max(results$adj_r2), ]["adj_r2_climate_pure"]
              list_k[[8]][m, 3] <- results[which.max(results$adj_r2), ]["adj_r2_human_pure"]
              
              list_k[[9]][m, 3] <- results[which.max(results$adj_r2), ]["pval_soil"]
              list_k[[10]][m, 3] <- results[which.max(results$adj_r2), ]["pval_climate"]
              list_k[[11]][m, 3] <- results[which.max(results$adj_r2), ]["pval_human"]
              list_k[[12]][m, 3] <- results[which.max(results$adj_r2), ]["pval_soil_pure"]
              list_k[[13]][m, 3] <- results[which.max(results$adj_r2), ]["pval_climate_pure"]
              list_k[[14]][m, 3] <- results[which.max(results$adj_r2), ]["pval_human_pure"]
              
              # add if/else statement in case that gbmem df has nrow = 0
              if (include_mem) {
                list_k[[15]][m, 3] <- results[which.max(results$adj_r2), ]["adj_r2_space_pure"]
                list_k[[16]][m, 3] <- results[which.max(results$adj_r2), ]["pval_space_pure"]
              } # end include_mem statement
              
            } # end include_varpart statement
            
            
            #### (B.4)  family level approach ####
            
            cdm <- shuffled_list[[k]][[m]] %>% 
              filter(!is.na(tax_fam)) %>% 
              group_by(plot_name, tax_fam) %>% 
              count() %>% 
              reshape::cast(., plot_name ~ tax_fam, value='n') %>%
              mutate_all(~replace(., is.na(.), 0)) %>%
              column_to_rownames(., var = "plot_name")
            
            # add MEMs to environmental predictor dataframe (if applicable)
            if (include_mem) {
              gbmem <- gbmem_list[[i]][[4]]
              env_bc_mem <- cbind(env_bc, gbmem)
            } else {
              env_bc_mem <- env_bc
            }
            
            ## synchronize cdm with env_bc_mem [18 Feb 2025]
            env_bc_mem <- env_bc_mem %>% 
              rownames_to_column(var = "plot_name") %>% 
              filter(plot_name %in% rownames(cdm)) %>% 
              column_to_rownames(var = "plot_name")
            
            ## create subsets of environmental predictors
            env_clim_sel <- env_bc_mem %>% dplyr::select(any_of(climate_vars)) # climate
            env_soil_sel <- env_bc_mem %>% dplyr::select(any_of(c(soil_vars, topo_vars))) # soil & topo
            env_human_sel <- env_bc_mem %>% dplyr::select(intersect(human_vars, names(env_rda))) # human only
            env_space_sel <- env_bc_mem %>% dplyr::select(starts_with("MEM")) # human only
            
            
            # Loop through BCC exponents and calculate RDA
            rda_results <- sapply(bcc_exp_list, function(bcc) {
              cdm_bcc <- box.cox.chord(cdm, bc.exp = bcc)
              
              # Fit RDA or CAP scale model
              if (method == "rda") {
                rda_temp <- vegan::rda(cdm_bcc ~ ., env_bc_mem, na.action = na.omit)
              } else {
                rda_temp <- vegan::capscale(cdm_bcc ~ ., env_bc_mem, comm = cdm_bcc, na.action = na.omit)
              }
              
              # Calculate adjusted R-squared
              adj_r2 <- RsquareAdj(rda_temp)$adj.r.squared
              
              # Perform ANOVA to get p-value
              # anova_results <- anova.cca(rda_temp, permutations = nperm_rda)
              # p_value <- anova_results$`Pr(>F)`[1]  # Get p-value
              
              ## get MSR-based manual p-value
              # get corresponding nullmodels
              adjR2_nullmod <- nullmod_all %>% 
                filter(fraction == "global" &
                         stratum == names(master_list)[[i]] &
                         resolution == "strict_sp")
              # calculate pval = proportion of values equal to or above the observed value (OH July 2024)
              p_value = sum(adjR2_nullmod$value >= adj_r2, na.rm=T) / sum(!is.na(adjR2_nullmod$value))
              
              if (include_varpart) {
                if (include_mem) {
                  ### retrieve partial adjR2 values from varpart
                  varpart <- varpart(cdm_bcc, env_soil_sel, env_clim_sel, env_human_sel, env_space_sel)
                  
                  adj_r2_soil <- as.data.frame(varpart$part$fract)[1,3] # soil X1 [aeghklno]
                  adj_r2_climate <- as.data.frame(varpart$part$fract)[2,3] # climate X2 [befiklmo]
                  adj_r2_human <- as.data.frame(varpart$part$fract)[3,3] # human X3 [cfgjlmno]
                  
                  # 'pure' & spatial fractions with the remaining two parcelled out
                  adj_r2_soil_pure <- as.data.frame(varpart$part$contr2)[3,3] # soil & soil+space | climate & human [ah]
                  adj_r2_climate_pure <- as.data.frame(varpart$part$contr2)[6,3] # climate & climate+space | soil & human [bi]
                  adj_r2_human_pure <- as.data.frame(varpart$part$contr2)[9,3] # human & human+space | soil & climate [cj]
                  
                  # pure spatial fraction
                  adj_r2_space_pure <- as.data.frame(varpart$part$indfract)[4,3] # spatial predictors pure fraction [d]
                  
                  ## Test of partial fractions
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil_pure" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate_pure" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human_pure" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  ### pval_space cannot be tested with MSR-based nullmodels, use anova.cca instead
                  pval_space_pure <- anova.cca(rda(cdm_bcc, env_space_sel, cbind(env_clim_sel, env_human_sel, env_soil_sel)), permutations = how(nperm = nperm_rda))[1,4]
                  
                  # Return a named vector of results
                  return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human, adj_r2_space_pure = adj_r2_space_pure, pval_soil = pval_soil, pval_climate = pval_climate, pval_human = pval_human, adj_r2_soil_pure = adj_r2_soil_pure, adj_r2_climate_pure = adj_r2_climate_pure, adj_r2_human_pure = adj_r2_human_pure, adj_r2_space_pure = adj_r2_space_pure, pval_soil_pure = pval_soil_pure, pval_climate_pure = pval_climate_pure, pval_human_pure = pval_human_pure, pval_space_pure = pval_space_pure))
                  
                } else {
                  ### retrieve partial adjR2 values from varpart
                  varpart <- varpart(cdm_bcc, env_soil_sel, env_clim_sel, env_human_sel)
                  
                  ## Venn diagram
                  # plot the variation partitioning Venn diagram
                  # vegan::showvarparts(3, Xnames = c("Soil", "Climate", "Human"), 
                  #                     bg = c("seagreen3", "mediumpurple", "red"), 
                  #                     alpha = 80) 
                  # plot(varpart,
                  #      Xnames = c("Soil", "Climate", "Human"), # name the partitions
                  #      bg = c("seagreen3", "mediumpurple", "red"), alpha = 80, # colour the circles
                  #      digits = 3, # only show 2 digits
                  #      cex = 0.6)
                  
                  # global fractions
                  adj_r2_soil <- as.data.frame(varpart$part$fract)[1,3] # soil X1 [adfg]
                  adj_r2_climate <- as.data.frame(varpart$part$fract)[2,3] # climate X2 [bdeg]
                  adj_r2_human <- as.data.frame(varpart$part$fract)[3,3] # human X3 [cefg]
                  
                  # pure fractions
                  adj_r2_soil_pure <- as.data.frame(varpart$part$indfract)[1,3] # soil pure fraction [a]
                  adj_r2_climate_pure <- as.data.frame(varpart$part$indfract)[2,3] # climate pure fraction [b]
                  adj_r2_human_pure <- as.data.frame(varpart$part$indfract)[3,3] # human pure fraction [c]
                  
                  ## Test of partial fractions
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "soil_pure" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_soil_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "climate_pure" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_climate_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  # get corresponding nullmodels
                  nullmod_sel <- nullmod_all %>% filter(fraction == "human_pure" & stratum == names(master_list)[[i]] & resolution == "family")
                  # calculate pval = proportion of values equal to or larger than above the observed value (OH July 2024)
                  pval_human_pure = sum(nullmod_sel$value >= adj_r2, na.rm=T) / sum(!is.na(nullmod_sel$value))
                  
                  
                  # Return a named vector of results
                  return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human, pval_soil = pval_soil, pval_climate = pval_climate, pval_human = pval_human, adj_r2_soil_pure = adj_r2_soil_pure, adj_r2_climate_pure = adj_r2_climate_pure, adj_r2_human_pure = adj_r2_human_pure, pval_soil_pure = pval_soil_pure, pval_climate_pure = pval_climate_pure, pval_human_pure = pval_human_pure))
                }
              } else { # if varpart not desired, return only global R2
                return(c(adj_r2 = adj_r2, p_value = p_value))
              }
            })
            
            # Convert results to a data frame for easier manipulation
            results <- as.data.frame(t(rda_results))
            
            ## this is filled in every possible combination of include_mem & include_varpart
            # Find the maximum adjusted R-squared and corresponding p-value
            list_k[[1]][m, 4] <- results[which.max(results$adj_r2), ]["adj_r2"]
            list_k[[2]][m, 4] <- results[which.max(results$adj_r2), ]["p_value"]
            
            ## this is filled only when include_varpart = TRUE
            if (include_varpart) {
              
              list_k[[3]][m, 4] <- results[which.max(results$adj_r2), ]["adj_r2_soil"]
              list_k[[4]][m, 4] <- results[which.max(results$adj_r2), ]["adj_r2_climate"]
              list_k[[5]][m, 4] <- results[which.max(results$adj_r2), ]["adj_r2_human"]
              
              list_k[[6]][m, 4] <- results[which.max(results$adj_r2), ]["adj_r2_soil_pure"]
              list_k[[7]][m, 4] <- results[which.max(results$adj_r2), ]["adj_r2_climate_pure"]
              list_k[[8]][m, 4] <- results[which.max(results$adj_r2), ]["adj_r2_human_pure"]
              
              list_k[[9]][m, 4] <- results[which.max(results$adj_r2), ]["pval_soil"]
              list_k[[10]][m, 4] <- results[which.max(results$adj_r2), ]["pval_climate"]
              list_k[[11]][m, 4] <- results[which.max(results$adj_r2), ]["pval_human"]
              list_k[[12]][m, 4] <- results[which.max(results$adj_r2), ]["pval_soil_pure"]
              list_k[[13]][m, 4] <- results[which.max(results$adj_r2), ]["pval_climate_pure"]
              list_k[[14]][m, 4] <- results[which.max(results$adj_r2), ]["pval_human_pure"]
              
              # add if/else statement in case that gbmem df has nrow = 0
              if (include_mem) {
                list_k[[15]][m, 4] <- results[which.max(results$adj_r2), ]["adj_r2_space_pure"]
                list_k[[16]][m, 4] <- results[which.max(results$adj_r2), ]["pval_space_pure"]
              } # end include_mem statement
              
            } # end include_varpart statement
            
            
          } # end nperm loop [m]
          
          return(list_k)
          
          
        } # end if statement
        
      } # end depth foreachloop [k]
      
      
      
      # Stop the cluster after computation
      stopCluster(cl)
      
      names(list_depth) <- c("depth_esp", "depth_gen", "depth_fam") # name list
      
      toc()
      
      
      
      ### final dataframe to capture in main master_list
      # 'final.df' contains the 3rd, 4th and 5th level of hierarchy: shuffling depth, taxonomic resolution and nperm
      
      # unnest lists based on second level hierarchy
      list_r2 <- lapply(list_depth, `[[`, 1)
      list_pval <- lapply(list_depth, `[[`, 2)
      
      r2 <- bind_rows(list_r2, .id = "depth") %>% 
        pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>% 
        mutate(valuetype = "adjR2") %>% 
        mutate(fraction = "global") %>% 
        rename(value = "adjR2") %>% 
        mutate(error = errors[[j]]) %>% 
        mutate(nperm = rep(c(rep(1:nperm, 
                                 each = 4, # 4 taxonomic resolutions
                                 sum(sapply(list_r2, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
      pval <- bind_rows(list_pval, .id = "depth") %>% 
        pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>% 
        mutate(valuetype = "pval") %>% 
        mutate(fraction = "global") %>% 
        rename(value = "adjR2") %>% 
        mutate(error = errors[[j]]) %>% 
        mutate(nperm = rep(c(rep(1:nperm, 
                                 each = 4, # 4 taxonomic resolutions
                                 sum(sapply(list_pval, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
      
      if (include_varpart) {
        list_r2_soil <- lapply(list_depth, `[[`, 3)
        list_r2_climate <- lapply(list_depth, `[[`, 4)
        list_r2_human <- lapply(list_depth, `[[`, 5)
        list_r2_soil_pure <- lapply(list_depth, `[[`, 6)
        list_r2_climate_pure <- lapply(list_depth, `[[`, 7)
        list_r2_human_pure <- lapply(list_depth, `[[`, 8)
        list_pval_soil <- lapply(list_depth, `[[`, 9)
        list_pval_climate <- lapply(list_depth, `[[`, 10)
        list_pval_human <- lapply(list_depth, `[[`, 11)
        list_pval_soil_pure <- lapply(list_depth, `[[`, 12)
        list_pval_climate_pure <- lapply(list_depth, `[[`, 13)
        list_pval_human_pure <- lapply(list_depth, `[[`, 14)
        
        
        r2_soil <- bind_rows(list_r2_soil, .id = "depth") %>% 
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>% 
          mutate(valuetype = "adjR2") %>%
          mutate(fraction = "soil") %>%
          rename(value = "adjR2") %>% 
          mutate(error = errors[[j]]) %>% 
          mutate(nperm = rep(c(rep(1:nperm, 
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_r2_soil, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        r2_climate <- bind_rows(list_r2_climate, .id = "depth") %>% 
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>% 
          mutate(valuetype = "adjR2") %>%
          mutate(fraction = "climate") %>%
          rename(value = "adjR2") %>% 
          mutate(error = errors[[j]]) %>% 
          mutate(nperm = rep(c(rep(1:nperm, 
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_r2_climate, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        r2_human <- bind_rows(list_r2_human, .id = "depth") %>% 
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>% 
          mutate(valuetype = "adjR2") %>%
          mutate(fraction = "human") %>%
          rename(value = "adjR2") %>% 
          mutate(error = errors[[j]]) %>% 
          mutate(nperm = rep(c(rep(1:nperm, 
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_r2_human, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        r2_soil_pure <- bind_rows(list_r2_soil_pure, .id = "depth") %>% 
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>% 
          mutate(valuetype = "adjR2") %>%
          mutate(fraction = "soil_pure") %>%
          rename(value = "adjR2") %>% 
          mutate(error = errors[[j]]) %>% 
          mutate(nperm = rep(c(rep(1:nperm, 
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_r2_soil_pure, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        r2_climate_pure <- bind_rows(list_r2_climate_pure, .id = "depth") %>% 
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>% 
          mutate(valuetype = "adjR2") %>%
          mutate(fraction = "climate_pure") %>%
          rename(value = "adjR2") %>% 
          mutate(error = errors[[j]]) %>% 
          mutate(nperm = rep(c(rep(1:nperm, 
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_r2_climate_pure, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        r2_human_pure <- bind_rows(list_r2_human_pure, .id = "depth") %>% 
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>% 
          mutate(valuetype = "adjR2") %>%
          mutate(fraction = "human_pure") %>%
          rename(value = "adjR2") %>% 
          mutate(error = errors[[j]]) %>% 
          mutate(nperm = rep(c(rep(1:nperm, 
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_r2_human_pure, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        
        pval_soil <- bind_rows(list_pval_soil, .id = "depth") %>%
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>%
          mutate(valuetype = "pval") %>%
          mutate(fraction = "soil") %>%
          rename(value = "adjR2") %>%
          mutate(error = errors[[j]]) %>% 
          mutate(nperm = rep(c(rep(1:nperm,
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_pval_soil, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        pval_climate <- bind_rows(list_pval_climate, .id = "depth") %>%
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>%
          mutate(valuetype = "pval") %>%
          mutate(fraction = "climate") %>%
          rename(value = "adjR2") %>%
          mutate(error = errors[[j]]) %>%
          mutate(nperm = rep(c(rep(1:nperm,
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_pval_climate, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        pval_human <- bind_rows(list_pval_human, .id = "depth") %>%
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>%
          mutate(valuetype = "pval") %>%
          mutate(fraction = "human") %>%
          rename(value = "adjR2") %>%
          mutate(error = errors[[j]]) %>%
          mutate(nperm = rep(c(rep(1:nperm,
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_pval_human, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        
        pval_soil_pure <- bind_rows(list_pval_soil_pure, .id = "depth") %>%
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>%
          mutate(valuetype = "pval") %>%
          mutate(fraction = "soil_pure") %>%
          rename(value = "adjR2") %>%
          mutate(error = errors[[j]]) %>%
          mutate(nperm = rep(c(rep(1:nperm,
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_pval_soil_pure, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        pval_climate_pure <- bind_rows(list_pval_climate_pure, .id = "depth") %>%
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>%
          mutate(valuetype = "pval") %>%
          mutate(fraction = "climate_pure") %>%
          rename(value = "adjR2") %>%
          mutate(error = errors[[j]]) %>%
          mutate(nperm = rep(c(rep(1:nperm,
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_pval_climate_pure, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        pval_human_pure <- bind_rows(list_pval_human_pure, .id = "depth") %>%
          pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>%
          mutate(valuetype = "pval") %>%
          mutate(fraction = "human_pure") %>%
          rename(value = "adjR2") %>%
          mutate(error = errors[[j]]) %>%
          mutate(nperm = rep(c(rep(1:nperm,
                                   each = 4, # 4 taxonomic resolutions
                                   sum(sapply(list_pval_human_pure, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
        
        if (include_mem) {
          list_r2_space_pure <- lapply(list_depth, `[[`, 15)
          r2_space_pure <- bind_rows(list_r2_space_pure, .id = "depth") %>% 
            pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>% 
            mutate(valuetype = "adjR2") %>%
            mutate(fraction = "space_pure") %>%
            rename(value = "adjR2") %>% 
            mutate(error = errors[[j]]) %>% 
            mutate(nperm = rep(c(rep(1:nperm, 
                                     each = 4, # 4 taxonomic resolutions
                                     sum(sapply(list_r2_space_pure, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
          
          list_pval_space_pure <- lapply(list_depth, `[[`, 16)
          pval_space_pure <- bind_rows(list_pval_space_pure, .id = "depth") %>%
            pivot_longer(cols = c("strict_sp", "morpho_sp", "genus", "family"), names_to = "resolution", values_to = "adjR2") %>%
            mutate(valuetype = "pval") %>%
            mutate(fraction = "space_pure") %>%
            rename(value = "adjR2") %>%
            mutate(error = errors[[j]]) %>%
            mutate(nperm = rep(c(rep(1:nperm,
                                     each = 4, # 4 taxonomic resolutions
                                     sum(sapply(list_pval_space_pure, Negate(is.null))))))) # 3 depth levels unless 'esp' or 'gen' are NULL in case of high OE
          
        } # if (include_mem)
        
        
      } # if (include_varpart)
      
      
      if (!include_varpart) {
        master_list[[i]][[j]] <- bind_rows(r2, pval)
      } else if (include_varpart & include_mem) {
        master_list[[i]][[j]] <- bind_rows(r2, pval, r2_soil, r2_climate, r2_human, r2_soil_pure, r2_climate_pure, r2_human_pure, r2_space_pure, pval_soil, pval_climate, pval_human, pval_soil_pure, pval_climate_pure, pval_human_pure, pval_space_pure)
      } else if (include_varpart & !include_mem) {
        master_list[[i]][[j]] <- bind_rows(r2, pval, r2_soil, r2_climate, r2_human, r2_soil_pure, r2_climate_pure, r2_human_pure, pval_soil, pval_climate, pval_human, pval_soil_pure, pval_climate_pure, pval_human_pure)
      }
      
      
      ## add diagnostics to diagnostics_master_list
      diagnostics_master_list[[i]][[j]] <- diagnostics.df
      
    } else { # close is.empty if statement 
      master_list[[i]][[j]] <- NULL
      diagnostics_master_list[[i]][[j]] <- NULL
    } 
    
    
  } # end error loop [j]
} # end strata loop [i]

toc()

#### unlist the 'master_list' into final dataframe ####
final.df_list <- list()
for (i in 1:length(master_list)) {
  final.df_list[[i]] <- bind_rows(master_list[[i]]) %>% 
    mutate(stratum = names(master_list[i]))
}
final.df <- bind_rows(final.df_list) %>% 
  filter(!is.na(value))

# reorder factor levels
final.df$stratum <- factor(final.df$stratum, levels = c("understory", "canopy"))
final.df$depth <- factor(final.df$depth, levels = c("depth_esp", "depth_gen", "depth_fam"))
final.df$resolution <- factor(final.df$resolution, levels = c("strict_sp", "morpho_sp", "genus", "family"))



if (include_varpart) {
  
  #### Effect of taxonomic resolution on variance explained ####
## (1) adjusted R2 of non-shuffled data
taxresolution_original <- final.df %>% 
  filter(error == 0 & nperm == 1 & depth == "depth_esp" & valuetype == "adjR2") %>% 
  dplyr::select(-error, -nperm, -depth, -valuetype) %>% 
  pivot_wider(names_from = fraction, values_from = value) %>% 
  dplyr::select(stratum, resolution, global, soil, climate, human, space_pure) %>% 
  arrange(resolution) %>% 
  mutate_if(is.numeric, round, 3)

## (2) relative change of R2 across four taxonomic resolutions
taxresolution_rel_increase <- final.df %>% 
  filter(error == 0 & nperm == 1 & depth == "depth_esp" & valuetype == "adjR2") %>% 
  dplyr::select(-error, -nperm, -depth, -valuetype) %>% 
  pivot_wider(names_from = fraction, values_from = value) %>% 
  group_by(stratum) %>%
  mutate(across(global:space_pure, 
                ~ . / .[resolution == "strict_sp"][1] * 100, # calculate reference values for "strict_sp"
                .names = "pct_{.col}")) %>%
  ungroup() %>% 
  dplyr::select(resolution, stratum, starts_with("pct")) %>% 
  mutate_if(is.numeric, round, 1) %>% 
  rename_with(~ gsub("^pct_", "",.), starts_with("pct_")) %>% 
  dplyr::select(stratum, resolution, global, soil, climate, human, space_pure) %>% 
  arrange(resolution)

## (3) combine tables 1 and 2 for
taxresolution_combined <- taxresolution_original %>%
  inner_join(taxresolution_rel_increase, by = c("stratum", "resolution"), suffix = c("_df1", "_df2")) %>%
  mutate(across(contains("_df1"), 
                ~ paste0(.x, " (", get(sub("_df1", "_df2", cur_column())), ")"), 
                .names = "{.col}_formatted")) %>%
  dplyr::select(resolution, stratum, ends_with("_formatted")) %>%
  rename_with(~ gsub("_df1_formatted", "", .x))



## (4) inter-predictor ratios for original data
taxresolution_ratios <- final.df %>% 
  filter(error == 0 & nperm == 1 & depth == "depth_esp" & valuetype == "adjR2" & fraction != "global") %>% 
  dplyr::select(-error, -nperm, -depth, -valuetype) %>% 
  pivot_wider(names_from = fraction, values_from = value) %>% 
  mutate(
    soil_pure_climate_pure = soil_pure / climate_pure,
    soil_pure_human_pure = soil_pure / human_pure,
    soil_pure_space_pure = soil_pure / space_pure,
    climate_pure_human_pure = climate_pure / human_pure,
    climate_pure_space_pure = climate_pure / space_pure,
    human_pure_space_pure = human_pure / space_pure
  ) %>% 
  dplyr::select(-soil, -climate, -human, -soil_pure, -climate_pure, -human_pure, -space_pure) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  arrange(resolution)
  
}  

```

```{r Plot decline patterns, echo=FALSE}

### set parameters
# plot pure or global fractions of varpart?
plot_pure_fraction <- TRUE
plot_inter_predictor_hierarchy <- TRUE
ylim <- 0.33 # set limit on y-axis for global R2
ylim_ratios <- 10

## add custom function to replace repeated 'mutate(size_category = ...)' call
add_size_category <- function(df) {
  df %>%
    mutate(size_category = case_when(
      pval_mean <= 0.01 ~ "small",
      pval_mean > 0.01 & pval_mean < 0.05 ~ "medium",
      pval_mean >= 0.05 & pval_mean < 0.1 ~ "large",
      pval_mean >= 0.1 ~ "very large"
    ))
}

#### (A.) Plot global adjusted R2 ####
#### (A.1) Understory ####
## depth = esp
plot <- final.df %>%
  filter(stratum == "understory" & depth == "depth_esp") %>%
  filter(fraction == "global") %>% 
  group_by(error, resolution) %>%
  summarise(
    mean = mean(value[valuetype == "adjR2"], na.rm = TRUE),
    sd = sd(value[valuetype == "adjR2"], na.rm = TRUE),
    pval_mean = mean(value[valuetype == "pval"], na.rm = TRUE),
    .groups = 'drop')
plot <- add_size_category(plot) # add size category for plotting

## plot decline in R2adj in function of identification
und_depth_esp <- ggplot(data=plot, 
                        aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = resolution, color=resolution)) +
  geom_line() +
  geom_ribbon(alpha = 0.5) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +
  ylim(0,ylim) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", size = "none") +
  ylab(paste0("mean adjusted R²")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d("Tax. resolution", labels = c("Species","Morphospecies", "Genus", "Family")) +
  scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  geom_hline(data = nullmod %>% 
               filter(stratum == "understory" & fraction == "global"), 
             aes(yintercept = mean, color = resolution), linetype = "dashed")

## depth = gen
plot <- final.df %>%
  filter(stratum == "understory" & depth == "depth_gen") %>%
  filter(fraction == "global") %>%
  group_by(error, resolution) %>%
  summarise(
    mean = mean(value[valuetype == "adjR2"], na.rm = TRUE),
    sd = sd(value[valuetype == "adjR2"], na.rm = TRUE),
    pval_mean = mean(value[valuetype == "pval"], na.rm = TRUE),
    .groups = 'drop')
plot <- add_size_category(plot) # add size category for plotting

## plot decline in R2adj in function of identification
und_depth_gen <- ggplot(data=plot, 
                        aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = resolution, color=resolution)) +
  geom_line() +
  geom_ribbon(alpha = 0.5) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +
  ylim(0,ylim) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  geom_hline(data = nullmod %>% 
               filter(stratum == "understory" & fraction == "global"), 
             aes(yintercept = mean, color = resolution), linetype = "dashed")

# depth == fam
plot <- final.df %>%
  filter(stratum == "understory" & depth == "depth_fam") %>%
  filter(fraction == "global") %>%
  group_by(error, resolution) %>%
  summarise(
    mean = mean(value[valuetype == "adjR2"], na.rm = TRUE),
    sd = sd(value[valuetype == "adjR2"], na.rm = TRUE),
    pval_mean = mean(value[valuetype == "pval"], na.rm = TRUE),
    .groups = 'drop')
plot <- add_size_category(plot) # add size category for plotting

## plot decline in R2adj in function of identification
und_depth_fam <- ggplot(data=plot, 
                        aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = resolution, color=resolution)) +
  geom_line() +
  geom_ribbon(alpha = 0.5) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +
  ylim(0,ylim) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  geom_hline(data = nullmod %>% 
               filter(stratum == "understory" & fraction == "global"), 
             aes(yintercept = mean, color = resolution), linetype = "dashed")

#### (A.2) Canopy ####
## depth = esp
plot <- final.df %>%
  filter(stratum == "canopy" & depth == "depth_esp") %>%
  filter(fraction == "global") %>%
  group_by(error, resolution) %>%
  summarise(
    mean = mean(value[valuetype == "adjR2"], na.rm = TRUE),
    sd = sd(value[valuetype == "adjR2"], na.rm = TRUE),
    pval_mean = mean(value[valuetype == "pval"], na.rm = TRUE),
    .groups = 'drop')
plot <- add_size_category(plot) # add size category for plotting

## plot decline in R2adj in function of identification
out_depth_esp <- ggplot(data=plot, 
                        aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = resolution, color=resolution)) +
  geom_line() +
  geom_ribbon(alpha = 0.5) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +
  ylim(0,ylim) +
  xlim(0,1) +
  xlab("") +
  guides(size = "none") +
  ylab(paste0("mean adjusted R²")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  geom_hline(data = nullmod %>% 
               filter(stratum == "canopy" & fraction == "global"), 
             aes(yintercept = mean, color = resolution), linetype = "dashed")

## depth = gen
plot <- final.df %>%
  filter(stratum == "canopy" & depth == "depth_gen") %>%
  filter(fraction == "global") %>%
  group_by(error, resolution) %>%
  summarise(
    mean = mean(value[valuetype == "adjR2"], na.rm = TRUE),
    sd = sd(value[valuetype == "adjR2"], na.rm = TRUE),
    pval_mean = mean(value[valuetype == "pval"], na.rm = TRUE),
    .groups = 'drop')
plot <- add_size_category(plot) # add size category for plotting

## plot decline in R2adj in function of identification
out_depth_gen <- ggplot(data=plot, 
                        aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = resolution, color=resolution)) +
  geom_line() +
  geom_ribbon(alpha = 0.5) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +
  ylim(0,ylim) +
  xlim(0,1) +
  xlab("") +
  guides(y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  geom_hline(data = nullmod %>% 
               filter(stratum == "canopy" & fraction == "global"), 
             aes(yintercept = mean, color = resolution), linetype = "dashed")

# depth == fam
plot <- final.df %>%
  filter(stratum == "canopy" & depth == "depth_fam") %>%
  filter(fraction == "global") %>%
  group_by(error, resolution) %>%
  summarise(
    mean = mean(value[valuetype == "adjR2"], na.rm = TRUE),
    sd = sd(value[valuetype == "adjR2"], na.rm = TRUE),
    pval_mean = mean(value[valuetype == "pval"], na.rm = TRUE),
    .groups = 'drop')
plot <- add_size_category(plot) # add size category for plotting

## plot decline in R2adj in function of identification
out_depth_fam <- ggplot(data=plot, 
                        aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = resolution, color=resolution)) +
  geom_line() +
  geom_ribbon(alpha = 0.5) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +
  ylim(0,ylim) +
  xlim(0,1) +
  xlab("") +
  guides(y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
  geom_hline(data = nullmod %>% 
               filter(stratum == "canopy" & fraction == "global"), 
             aes(yintercept = mean, color = resolution), linetype = "dashed")


# add label to plots
# und_depth_esp <- annotate_figure(und_depth_esp,
#   top = text_grob("Understory",
#     face = "bold", size = 12, hjust = 0, x = unit(40, "pt")))
# out_depth_esp <- annotate_figure(out_depth_esp,
#   top = text_grob("Canopy",
#     face = "bold", size = 12, hjust = 0, x = unit(40, "pt")))

### Arrange figure with ggpubr [formated for DIN A5 PDF plotting]
(figure <- ggpubr::ggarrange(und_depth_esp, und_depth_gen, und_depth_fam, 
                             out_depth_esp, out_depth_gen, out_depth_fam, 
                             # labels = c("Species level", "Genus level", "Family level"), 
                             vjust= 0,
                             font.label = list(size = 11, color = "black", face = "bold", family = NULL),
                             label.y = 0.9, label.x = 0.1,
                             ncol = 3, nrow = 2, common.legend = TRUE) + 
  annotation_custom(grob = textGrob("Understory", gp = gpar(fontsize = 12, fontface = "bold")), 
                    xmin = 0.13, xmax = 0.13, ymin = 0.89, ymax = 0.89) +
  annotation_custom(grob = textGrob("Intra-genus schuffling", gp = gpar(fontsize = 11)), 
                    xmin = 0.2, xmax = 0.2, ymin = 0.86, ymax = 0.86) +
  annotation_custom(grob = textGrob("Intra-family schuffling", gp = gpar(fontsize = 11)), 
                    xmin = 0.5, xmax = 0.5, ymin = 0.86, ymax = 0.86) +
  annotation_custom(grob = textGrob("Inter-family schuffling", gp = gpar(fontsize = 11)), 
                    xmin = 0.85, xmax = 0.85, ymin = 0.86, ymax = 0.86) +
  annotation_custom(grob = textGrob("Canopy", gp = gpar(fontsize = 12, fontface = "bold")), 
                    xmin = 0.115, xmax = 0.115, ymin = 0.47, ymax = 0.47))



#### (B.) Plot partial R2 decline patterns ####

if (include_varpart) {

## use this to decide whether we plot global or pure fractions
if (plot_pure_fraction) {
  
  final.df2 <- final.df %>%
    filter(str_detect(fraction, "_pure")) %>%
    mutate(fraction = gsub("soil_pure", "soil", fraction),
           fraction = gsub("climate_pure", "climate", fraction),
           fraction = gsub("human_pure", "human", fraction),
           fraction = gsub("space_pure", "space", fraction))
  
  
  nullmod2 <- nullmod %>% 
    filter(str_detect(fraction, "_pure")) %>%
    mutate(fraction = gsub("soil_pure", "soil", fraction),
           fraction = gsub("climate_pure", "climate", fraction),
           fraction = gsub("human_pure", "human", fraction))
  
  
} else {
  final.df2 <- final.df %>%
    filter(!str_detect(fraction, "_pure"))
  
  nullmod2 <- nullmod %>% 
    filter(!str_detect(fraction, "_pure"))
  
}

# set xlim for plots 
xlim_partR2 <- as.numeric(final.df2 %>% filter(valuetype == "adjR2") %>% summarise(max = max(value)))+0.005



#### (B.1) Understory ####
### depth = esp 
## resolution = strict_sp
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "strict_sp", 
         depth == "depth_esp" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "strict_sp", 
         depth == "depth_esp" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))
# add point size category
plot <- add_size_category(plot)
# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_esp_strict_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color=fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", size = "none") +
  ylab(paste0("mean adjusted R2")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "strict_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


## depth = esp / resolution = morpho_sp
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "morpho_sp", 
         depth == "depth_esp" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "morpho_sp", 
         depth == "depth_esp" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))
# add point size category
plot <- add_size_category(plot)
# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_esp_morpho_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "morpho_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")

## depth = esp / resolution = genus
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "genus", 
         depth == "depth_esp" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "genus", 
         depth == "depth_esp" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))
# add point size category
plot <- add_size_category(plot)
# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_esp_genus <- ggplot(data=plot, 
                                      aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")



## depth = esp / resolution = family
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "family", 
         depth == "depth_esp" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "family", 
         depth == "depth_esp" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))
# add point size category
plot <- add_size_category(plot)
# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_esp_family <- ggplot(data=plot, 
                                       aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


### depth = gen
## resolution = strict_sp
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "strict_sp", 
         depth == "depth_gen" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "strict_sp", 
         depth == "depth_gen" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))
# add point size category
plot <- add_size_category(plot)
# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_gen_strict_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", size = "none") +
  ylab(paste0("mean adjusted R2")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "strict_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")



## resolution = morpho_sp
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "morpho_sp", 
         depth == "depth_gen" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "morpho_sp", 
         depth == "depth_gen" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))
# add point size category
plot <- add_size_category(plot)
# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_gen_morpho_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "morpho_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")

## resolution = genus
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "genus", 
         depth == "depth_gen" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "genus", 
         depth == "depth_gen" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))
# add point size category
plot <- add_size_category(plot)
# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_gen_genus <- ggplot(data=plot, 
                                      aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")



## resolution = family
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "family", 
         depth == "depth_gen" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "family", 
         depth == "depth_gen" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))
# add point size category
plot <- add_size_category(plot)
# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_gen_family <- ggplot(data=plot, 
                                       aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


### depth = fam
## resolution = strict_sp
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "strict_sp", 
         depth == "depth_fam" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "strict_sp", 
         depth == "depth_fam" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))
# add point size category
plot <- add_size_category(plot)
# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_fam_strict_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(size = "none") +
  ylab(paste0("mean adjusted R2")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "strict_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


## resolution = morpho_sp
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "morpho_sp", 
         depth == "depth_fam" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "morpho_sp", 
         depth == "depth_fam" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))
# add point size category
plot <- add_size_category(plot)
# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_fam_morpho_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "morpho_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")

## resolution = genus
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "genus", 
         depth == "depth_fam" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "genus", 
         depth == "depth_fam" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_fam_genus <- ggplot(data=plot, 
                                      aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


## resolution = family
plot <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "family", 
         depth == "depth_fam" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "understory" & resolution == "family", 
         depth == "depth_fam" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
und_partial_depth_fam_family <- ggplot(data=plot, 
                                       aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "understory" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")



#### (B.2) Canopy ####
### depth = esp 
## resolution = strict_sp
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "strict_sp", 
         depth == "depth_esp" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "strict_sp", 
         depth == "depth_esp" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_esp_strict_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", size = "none") +
  ylab(paste0("mean adjusted R2")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "strict_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


## depth = esp / resolution = morpho_sp
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "morpho_sp", 
         depth == "depth_esp" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "morpho_sp", 
         depth == "depth_esp" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_esp_morpho_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "morpho_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")

## depth = esp / resolution = genus
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "genus", 
         depth == "depth_esp" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "genus", 
         depth == "depth_esp" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_esp_genus <- ggplot(data=plot, 
                                      aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


## depth = esp / resolution = family
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "family", 
         depth == "depth_esp" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "family", 
         depth == "depth_esp" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_esp_family <- ggplot(data=plot, 
                                       aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")



### depth = gen
## resolution = strict_sp
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "strict_sp", 
         depth == "depth_gen" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "strict_sp", 
         depth == "depth_gen" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_gen_strict_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", size = "none") +
  ylab(paste0("mean adjusted R2")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "strict_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")



## resolution = morpho_sp
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "morpho_sp", 
         depth == "depth_gen" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "morpho_sp", 
         depth == "depth_gen" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_gen_morpho_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "morpho_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")

## resolution = genus
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "genus", 
         depth == "depth_gen" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "genus", 
         depth == "depth_gen" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_gen_genus <- ggplot(data=plot, 
                                      aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


## resolution = family
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "family", 
         depth == "depth_gen" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "family", 
         depth == "depth_gen" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_gen_family <- ggplot(data=plot, 
                                       aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +   
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(x = "none", y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


### depth = fam
## resolution = strict_sp
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "strict_sp", 
         depth == "depth_fam" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "strict_sp", 
         depth == "depth_fam" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_fam_strict_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(size = "none") +
  ylab(paste0("mean adjusted R2")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "strict_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


## resolution = morpho_sp
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "morpho_sp", 
         depth == "depth_fam" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "morpho_sp", 
         depth == "depth_fam" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_fam_morpho_sp <- ggplot(data=plot, 
                                          aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "morpho_sp" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")

## resolution = genus
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "genus", 
         depth == "depth_fam" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "genus", 
         depth == "depth_fam" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_fam_genus <- ggplot(data=plot, 
                                      aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


## resolution = family
plot <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "family", 
         depth == "depth_fam" & valuetype == "adjR2" & fraction != "global") %>% 
  group_by(error, fraction) %>% 
  summarize(mean = mean(value), sd = sd(value), .groups = 'drop')

# Create a new data frame with both R² values and p-values
pval_data <- final.df2 %>% 
  filter(stratum == "canopy" & resolution == "family", 
         depth == "depth_fam" & valuetype == "pval" & fraction != "global") %>% 
  group_by(error) %>% 
  summarize(soil = mean(value[fraction == "soil"], na.rm = TRUE),
            climate = mean(value[fraction == "climate"], na.rm = TRUE),
            human = mean(value[fraction == "human"], na.rm = TRUE),
            space = mean(value[fraction == "space"], na.rm = TRUE),
            .groups = 'drop') %>% 
  pivot_longer(cols = c("soil", "climate", "human", "space"), names_to = "fraction", values_to = "pval_mean") %>% 
  arrange(error, fraction)

# Join the two data frames to associate p-values with R² values
plot <- left_join(plot, pval_data, by = c("error", "fraction"))

# add point size category
plot <- add_size_category(plot)

# reorder factor levels
plot$fraction <- factor(plot$fraction, levels = c("soil", "climate", "human", "space"))

## plot decline in partial R2adj in function of identification error
can_partial_depth_fam_family <- ggplot(data=plot, 
                                       aes(x=error, y=mean, ymin= mean-sd, ymax = mean+sd, fill = fraction, color = fraction)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  geom_point(aes(size = size_category)) +
  scale_size_manual(values = c("small" = 1.5, "medium" = 2.5, "large" = 3.5, "very large" = 4.5)) +    
  ylim(-0.01,xlim_partR2) +
  xlim(0,1) +
  xlab("") +
  guides(y = "none", size = "none") +
  ylab(paste0("")) +
  theme_minimal() +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  scale_color_viridis_d(option = "F", "Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  scale_fill_viridis_d(option = "F","Partial R2", labels = c("soil", "climate", "human activity", "space")) +
  geom_hline(data = nullmod2 %>% 
               filter(stratum == "canopy" & resolution == "genus" & fraction != "global"), 
             aes(yintercept = mean, color = fraction), linetype = "dashed")


### Arrange figure with ggpubr: understory
(figure1 <- ggpubr::ggarrange(und_partial_depth_esp_strict_sp, und_partial_depth_esp_morpho_sp, und_partial_depth_esp_genus, und_partial_depth_esp_family, 
                              und_partial_depth_gen_strict_sp, und_partial_depth_gen_morpho_sp, und_partial_depth_gen_genus, und_partial_depth_gen_family,
                              und_partial_depth_fam_strict_sp, und_partial_depth_fam_morpho_sp, und_partial_depth_fam_genus, und_partial_depth_fam_family,
                              # labels = c("strict species", "morpho taxon", "genus", "family"), 
                              vjust= 0,
                              font.label = list(size = 11, color = "black", face = "bold", family = NULL),
                              label.y = 0.9, label.x = 0.1,
                              ncol = 4, nrow = 3, common.legend = TRUE) + 
  annotation_custom(grob = textGrob("Intra-genus schuffling", gp = gpar(fontsize = 12, fontface = "bold")), 
                    xmin = 0.15, xmax = 0.15, ymin = 0.93, ymax = 0.93) +
  annotation_custom(grob = textGrob("Species", gp = gpar(fontsize = 11)), 
                    xmin = 0.16, xmax = 0.16, ymin = 0.9, ymax = 0.9) +
      annotation_custom(grob = textGrob("Morphospecies", gp = gpar(fontsize = 11)), 
                    xmin = 0.38, xmax = 0.38, ymin = 0.9, ymax = 0.9) +
      annotation_custom(grob = textGrob("Genus", gp = gpar(fontsize = 11)), 
                    xmin = 0.635, xmax = 0.635, ymin = 0.9, ymax = 0.9) +
      annotation_custom(grob = textGrob("Family", gp = gpar(fontsize = 11)), 
                    xmin = 0.885, xmax = 0.885, ymin = 0.9, ymax = 0.9) +
  annotation_custom(grob = textGrob("Intra-family shuffling", gp = gpar(fontsize = 12, fontface = "bold")), 
                    xmin = 0.15, xmax = 0.15, ymin = 0.6, ymax = 0.6) +
  annotation_custom(grob = textGrob("Inter-family shuffling", gp = gpar(fontsize = 12, fontface = "bold")), 
                    xmin = 0.15, xmax = 0.15, ymin = 0.29, ymax = 0.29))

### Arrange figure with ggpubr: canopy
(figure2 <- ggpubr::ggarrange(can_partial_depth_esp_strict_sp, can_partial_depth_esp_morpho_sp, can_partial_depth_esp_genus, can_partial_depth_esp_family, 
                              can_partial_depth_gen_strict_sp, can_partial_depth_gen_morpho_sp, can_partial_depth_gen_genus, can_partial_depth_gen_family,
                              can_partial_depth_fam_strict_sp, can_partial_depth_fam_morpho_sp, can_partial_depth_fam_genus, can_partial_depth_fam_family,
                              # labels = c("strict species", "morpho taxon", "genus", "family"), 
                              vjust= 0,
                              font.label = list(size = 11, color = "black", face = "bold", family = NULL),
                              label.y = 0.9, label.x = 0.1,
                              ncol = 4, nrow = 3, common.legend = TRUE) + 
  annotation_custom(grob = textGrob("Intra-genus schuffling", gp = gpar(fontsize = 12, fontface = "bold")), 
                    xmin = 0.15, xmax = 0.15, ymin = 0.93, ymax = 0.93) +
  annotation_custom(grob = textGrob("Species", gp = gpar(fontsize = 11)), 
                    xmin = 0.16, xmax = 0.16, ymin = 0.9, ymax = 0.9) +
      annotation_custom(grob = textGrob("Morphospecies", gp = gpar(fontsize = 11)), 
                    xmin = 0.38, xmax = 0.38, ymin = 0.9, ymax = 0.9) +
      annotation_custom(grob = textGrob("Genus", gp = gpar(fontsize = 11)), 
                    xmin = 0.635, xmax = 0.635, ymin = 0.9, ymax = 0.9) +
      annotation_custom(grob = textGrob("Family", gp = gpar(fontsize = 11)), 
                    xmin = 0.885, xmax = 0.885, ymin = 0.9, ymax = 0.9) +
  annotation_custom(grob = textGrob("Intra-family shuffling", gp = gpar(fontsize = 12, fontface = "bold")), 
                    xmin = 0.15, xmax = 0.15, ymin = 0.6, ymax = 0.6) +
  annotation_custom(grob = textGrob("Inter-family shuffling", gp = gpar(fontsize = 12, fontface = "bold")), 
                    xmin = 0.15, xmax = 0.15, ymin = 0.29, ymax = 0.29))



#### (C.) exploring inter-predictor ratios ####

if (plot_inter_predictor_hierarchy) {
  
  # initiate list to capture plots
  df_list <- list(understory = list(depth_esp = list(), depth_gen= list(), depth_fam = list()), canopy = list(depth_esp = list(), depth_gen= list(), depth_fam = list()))
  
  for (h in unique(final.df$stratum)) {
    for (i in unique(final.df$depth)) {
      for (j in unique(final.df$resolution)) {
        
        df <- final.df %>% 
          filter(fraction %in% c("soil_pure", "climate_pure", "human_pure", "space_pure")) %>% 
          filter(stratum == h) %>% 
          filter(depth == i) %>% 
          filter(resolution == j) %>% 
          group_by(fraction, error) %>% 
          summarise(mean = mean(value)) %>% 
          pivot_wider(names_from = fraction, values_from = mean) %>% 
          mutate(ratio_soil_climate = soil_pure/climate_pure,
                 ratio_soil_human = soil_pure/human_pure,
                 ratio_soil_space = soil_pure/space_pure,
                 ratio_climate_human = climate_pure/human_pure,
                 ratio_climate_space = climate_pure/space_pure,
                 ratio_human_space = human_pure/space_pure) %>% 
          dplyr::select(-soil_pure, -climate_pure, -human_pure, -space_pure) %>% 
          pivot_longer(cols = 2:7, names_to = "ratio", values_to = "value")
        
        df_list[[h]][[i]][[j]] <- df %>% 
          mutate(stratum = h, 
                 depth = i, 
                 resolution = j)
        
      }
    }
  }
  
  
  
  inter_predictor_ratios <- bind_rows(bind_rows(df_list[[1]][[1]]), bind_rows(df_list[[1]][[2]]), bind_rows(df_list[[1]][[3]]), bind_rows(df_list[[2]][[1]]), bind_rows(df_list[[2]][[2]]), bind_rows(df_list[[2]][[3]]))
  
  # reorder factor levels
  inter_predictor_ratios$stratum <- factor(inter_predictor_ratios$stratum, levels = c("understory", "canopy"))
  inter_predictor_ratios$depth <- factor(inter_predictor_ratios$depth, levels = c("depth_esp", "depth_gen", "depth_fam"))
  inter_predictor_ratios$resolution <- factor(inter_predictor_ratios$resolution, levels = c("strict_sp", "morpho_sp", "genus", "family"))
  
 
  inter_predictor_ratios$error[inter_predictor_ratios$error == 0.00] <- 0
  inter_predictor_ratios$error[inter_predictor_ratios$error == 1.00] <- 1
  inter_predictor_ratios$error[inter_predictor_ratios$error == 0.50] <- 0.5
  
  #### [new] plot by ratio
  
  plot_list <- list()
  for (h in unique(inter_predictor_ratios$stratum)) {
    
    ## Soil:climate
    a1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_soil_climate") %>% 
                   filter(depth == "depth_esp")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "soil:climate", color = "") +
      theme(axis.text.x = element_blank())
    
    # remove y-axis label and numbering for canopy part of the plot
    if (h == "canopy") {
      a1 <- a1 +
        theme(axis.text.y = element_blank()) +
        labs(y = "")
    }

    
    b1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_soil_climate") %>% 
                   filter(depth == "depth_gen")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "", color = "") +
      theme(axis.text.x = element_blank(), axis.text.y = element_blank())
    
    c1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_soil_climate") %>% 
                   filter(depth == "depth_fam")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs( title = "", x = "", y = "", color = "") +
      theme(axis.text.x = element_blank(), axis.text.y = element_blank())
    
    ## Soil:human
    d1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_soil_human") %>% 
                   filter(depth == "depth_esp")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "soil:human", color = "") +
      theme(axis.text.x = element_blank())
    
    # remove y-axis label and numbering for canopy part of the plot
    if (h == "canopy") {
      d1 <- d1 +
        theme(axis.text.y = element_blank()) +
        labs(y = "")
    }
    
    e1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_soil_human") %>% 
                   filter(depth == "depth_gen")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "", color = "") +
      theme(axis.text.x = element_blank(), axis.text.y = element_blank())
    
    f1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_soil_human") %>% 
                   filter(depth == "depth_fam")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "", color = "") +
      theme(axis.text.x = element_blank(), axis.text.y = element_blank())
    
    ## climate:human
    g1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_climate_human") %>% 
                   filter(depth == "depth_esp")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "climate:human", color = "") +
      theme(axis.text.x = element_blank())
    
    # remove y-axis label and numbering for canopy part of the plot
    if (h == "canopy") {
      g1 <- g1 +
        theme(axis.text.y = element_blank()) +
        labs(y = "")
    }
    
    h1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_climate_human") %>% 
                   filter(depth == "depth_gen")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "", color = "") +
      theme(axis.text.x = element_blank(), axis.text.y = element_blank())
    
    
    i1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_climate_human") %>% 
                   filter(depth == "depth_fam")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "", color = "") +
      theme(axis.text.x = element_blank(), axis.text.y = element_blank())
    
    j1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_soil_space") %>% 
                   filter(depth == "depth_esp")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "soil:space", color = "") +
      theme(axis.text.x = element_blank())
    
    # remove y-axis label and numbering for canopy part of the plot
    if (h == "canopy") {
      j1 <- j1 +
        theme(axis.text.y = element_blank()) +
        labs(y = "")
    }
    
    k1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_soil_space") %>% 
                   filter(depth == "depth_gen")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs( title = "", x = "", y = "", color = "") +
      theme(axis.text.x = element_blank(), axis.text.y = element_blank())
    
    l1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_soil_space") %>% 
                   filter(depth == "depth_fam")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "", color = "") +
      theme(axis.text.x = element_blank(), axis.text.y = element_blank())
    
    m1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_climate_space") %>% 
                   filter(depth == "depth_esp")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "climate:space", color = "") +
      theme(axis.text.x = element_blank())
    
    # remove y-axis label and numbering for canopy part of the plot
    if (h == "canopy") {
      m1 <- m1 +
        theme(axis.text.y = element_blank()) +
        labs(y = "")
    }
    
    n1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_climate_space") %>% 
                   filter(depth == "depth_gen")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "", color = "") +
      theme(axis.text.x = element_blank(), axis.text.y = element_blank())
    
    o1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_climate_space") %>% 
                   filter(depth == "depth_fam")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "", color = "") +
      theme(axis.text.x = element_blank(), axis.text.y = element_blank())
    
    p1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_human_space") %>% 
                   filter(depth == "depth_esp")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "human:space", color = "") +
      theme(axis.text.x = element_text(angle = 90, hjust = 1))
      scale_x_continuous(
        breaks = c(0, 0.25, 0.5, 0.75, 1),  # Specify the breaks you want to label
        labels = c("0", "0.25", "0.5", "0.75", "1"))  # Custom labels for each break
    
    
    # remove y-axis label and numbering for canopy part of the plot
    if (h == "canopy") {
      p1 <- p1 +
        theme(axis.text.y = element_blank()) +
        labs(y = "")
    }
    
    q1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_human_space") %>% 
                   filter(depth == "depth_gen")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "", x = "", y = "", color = "") +
      theme(axis.text.y = element_blank(), axis.text.x = element_text(angle = 90, hjust = 1))
      scale_x_continuous(
        breaks = c(0, 0.25, 0.5, 0.75, 1),  # Specify the breaks you want to label
        labels = c("0", "0.25", "0.5", "0.75", "1"))  # Custom labels for each break
    
    r1 <- ggplot(inter_predictor_ratios %>% 
                   filter(stratum == h) %>% 
                   filter(ratio == "ratio_human_space") %>% 
                   filter(depth == "depth_fam")
                 , aes(x = error, y = value, color = resolution)) + 
      geom_line() +
      xlim(0, 1) + ylim(0,ylim_ratios) +
      scale_color_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      scale_fill_viridis_d("Tax. resolution", labels = c("Species", "Morphospecies", "Genus", "Family")) +
      theme_minimal() +
      labs(title = "",x = "", y = "", color = "") +
      theme(axis.text.y = element_blank(), axis.text.x = element_text(angle = 90, hjust = 1))
      scale_x_continuous(
        breaks = c(0, 0.25, 0.5, 0.75, 1),  # Specify the breaks you want to label
        labels = c("0", "0.25", "0.5", "0.75", "1"))  # Custom labels for each break
    
    

    
    ## composite plot with all ratios [formated for DIN A4 portrait]
    plot_list[[h]] <- plot(ggpubr::ggarrange(a1,b1,c1,d1,e1,f1,j1,k1,l1,g1,h1,i1,m1,n1,o1,p1,q1,r1, ncol = 3, nrow = 6, common.legend = TRUE, legend = "none") +
                              annotation_custom(grob = textGrob("Intra-genus", gp = gpar(fontsize = 12)), 
                                                xmin = 0.2, xmax = 0.2, ymin = 0.98, ymax = 0.98) +
                              annotation_custom(grob = textGrob("Intra-family", gp = gpar(fontsize = 12)), 
                                                xmin = 0.54, xmax = 0.54, ymin = 0.98, ymax = 0.98) +
                              annotation_custom(grob = textGrob("Inter-family", gp = gpar(fontsize = 12)), 
                                                xmin = 0.87, xmax = 0.87, ymin = 0.98, ymax = 0.98))
    
  }
  

  (interpredictor_ratios_figure <- ggpubr::ggarrange(plot_list[[1]], plot_list[[2]], ncol = 2, nrow = 1, common.legend = TRUE) +
    annotation_custom(grob = textGrob("observer error", gp = gpar(fontsize = 12, fontface = "bold")), 
                      xmin = 0.5, xmax = 0.5, ymin = 0.01, ymax = 0.01))
  
} # end if statement

} # end if(include_varpart) statement

```

```{r exponential decay models and two-way ANOVA, echo=FALSE}

anova_result <- list(boxplot = list(), table = list())

for (h in unique(final.df$stratum)) {
  
### comparing means with two-way ANOVA
df <- final.df %>% 
  filter(stratum == h) %>%
  filter(valuetype == "adjR2") %>% 
  filter(fraction == "global")

# get nperm
nperm <- max(df$nperm)
 
df$resolution <- factor(df$resolution, levels = c("strict_sp", "morpho_sp", "genus", "family"))
df$depth <- factor(df$depth, levels = c("depth_esp", "depth_gen", "depth_fam"))

 
#### (A.) fit exponential decay models ####
# initiate list
parm_list <- list()

for (i in unique(df$depth)) { # loop over stratum
  for (j in unique(df$resolution)) { # loop over shuffling_depth

    ## let's try with global R2 decline
    df1 <- df %>% 
      filter(depth == i) %>% 
      filter(resolution == j)
    
    
    ## fit nonlinear model only if variance is non-zero (this avoids fitting models to horizontal lines)
    if (var(df1$value) != 0) {
      
      #### select nonlinear function ####
      ## fit dose-response-curve (dose = error; response = adjR2)
      # Function "DRC.expoDecay()" cannot be found but "[...] the ‘drc’ package also contains the function ‘EXD.2()’, that fits an exponential decay model, with a slightly different parameterisation: 𝑌=𝑑exp(−𝑥/𝑒)."
      drm.fit <- drm(value~error,
                     curveid = nperm, # grouping variable [resolution]
                     data = df1, 
                     fct = EXD.2()) # select function
      
      
      # get model fit parameters (1st row = intercept, 2nd row = )
      drm.fit.parm <- as.data.frame(drm.fit$parmMat) %>% 
        mutate(depth = i) %>% 
        mutate(resolution = j) %>% 
        mutate(type = c("d", "e"))
      
      parm_list[[i]][[j]] <- drm.fit.parm
      
      
      library(viridis)
      colvec <- viridis(nperm)
      
      ## plot models
      # DRC package and ggplot? https://stackoverflow.com/questions/36780357/plotting-dose-response-curves-with-ggplot2-and-drc
      plot(drm.fit, 
           xlim = c(min(unlist(errors)), max(unlist(errors))), 
           ylim = c(0, 0.35),
           col = colvec,
           lty = c(rep(1,nperm)), # make all curves 'simple'
           pch = NA,
           cex.legend = 0.7,
           main = paste0("Fitted exponential decay model \n", i, " / ", j)) # remove points
      
    }
    
  } # close j loop (depth)
} # close i loop (stratum)

## assemble all parameters
parm_all <- bind_rows(bind_rows(parm_list[[1]]), bind_rows(parm_list[[2]]), bind_rows(parm_list[[3]])) %>% 
  pivot_longer(., cols = c(rep(1:nperm)), names_to = "nperm", values_to = "value")


#### (B.) Statistical testing ####

parm_to_test_all <- parm_all %>% 
  filter(type == "e") %>%  # test for differences in parameter 'e' (slope)
  mutate(value_log = log(value)) %>% 
  mutate(value_log10 = log10(value))

## delete outliers: mean + 2 standard deviations
mean_value <- median(parm_to_test_all$value)
sd_value <- sd(parm_to_test_all$value)
threshold <- mean_value + 2*sd_value

## select value for testing
parm_to_test <- parm_to_test_all %>% 
  dplyr::select(depth, resolution, nperm, value_log) %>% 
  rename(value = 4) %>% 
  filter(value < threshold) %>% 
  filter(value < 5) #### NOTE: manually delete outlier-like value ####

# reorder factor levels
parm_to_test$resolution <- factor(parm_to_test$resolution, levels = c("strict_sp", "morpho_sp", "genus", "family"))
parm_to_test$depth <- factor(parm_to_test$depth, levels = c("depth_esp", "depth_gen", "depth_fam"))


#### replace 'depth' with new terminology ####
levels(parm_to_test$resolution)[levels(parm_to_test$resolution) == "strict_sp"] <- "Species"
levels(parm_to_test$resolution)[levels(parm_to_test$resolution) == "morpho_sp"] <- "Morphospecies"
levels(parm_to_test$resolution)[levels(parm_to_test$resolution) == "genus"] <- "Genus"
levels(parm_to_test$resolution)[levels(parm_to_test$resolution) == "family"] <- "Family"
parm_to_test$resolution <- factor(parm_to_test$resolution, levels = c("Species", "Morphospecies", "Genus", "Family"))

levels(parm_to_test$depth)[levels(parm_to_test$depth) == "depth_esp"] <- "intra-genus"
levels(parm_to_test$depth)[levels(parm_to_test$depth) == "depth_gen"] <- "intra-family"
levels(parm_to_test$depth)[levels(parm_to_test$depth) == "depth_fam"] <- "inter-family"
parm_to_test$depth <- factor(parm_to_test$depth, levels = c("intra-genus", "intra-family", "inter-family"))


(bxp <- ggboxplot(
  parm_to_test, x = "depth", y = "value",
  color = "resolution", palette = viridis(4))+ ylim(-1,2))

#### (B.1) normality & homoscedasticity assumptions ####
# Build the linear model
mod <- lm(value ~ depth*resolution,
             data = parm_to_test)
# Q-Q plot of theoretical normal distribution and data
ggpubr::ggqqplot(residuals(mod))
# Normality of residuals: normality can be assumed if shapiro test is n.s.
shapiro_test(residuals(mod))
# normality of group-wise values: normality can be assumed if shapiro test is n.s.
(parm_to_test %>%
  group_by(depth, resolution) %>%
  shapiro_test(value))
# group-wise Q-Q plot
ggqqplot(parm_to_test, "value", ggtheme = theme_bw()) +
  facet_grid(depth ~ resolution)

## homogeneity of variances (Levene test)
(variances <- parm_to_test %>% 
  group_by(depth, resolution) %>% 
  summarise(variance = var(value)))

# variances are homogeneous if levene test is n.s.
parm_to_test %>%
  rstatix::levene_test(value ~ depth*resolution)

#### (B.2) Two-way ANOVA ####
(res.aov <- parm_to_test %>% anova_test(value ~ depth * resolution))

#### (B.3) Post-hoc tests (EMM) ####
# pairwise comparisons
(pwc <- parm_to_test %>%
  group_by(depth) %>%
  emmeans_test(value ~ resolution, p.adjust.method = "holm"))


## Visualization: box plots with p-values
# plot original e parameter values with tests on log transformed values
pwc <- pwc %>% add_xy_position(x = "depth")

anova_result[[1]][[h]] <- print(bxp +
  stat_pvalue_manual(pwc, hide.ns = TRUE) +
  labs(title = h,
    subtitle = get_test_label(res.aov, detailed = TRUE),
    caption = get_pwc_label(pwc)))


## add table to result slot
anova_result[[2]][[h]] <- parm_to_test_all %>% group_by(depth, resolution) %>% summarise(mean = mean(value), sd = sd(value)) %>% mutate(stratum = h)


} # end loop

(decayconstant_boxplot <- ggpubr::ggarrange(anova_result[[1]][[1]], anova_result[[1]][[2]], ncol = 2, nrow = 1, common.legend = TRUE))

decayconstant_table <- bind_rows(anova_result[[2]][[1]], anova_result[[2]][[2]]) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  mutate(decay_constant = paste0(mean, " ± ", sd)) %>% 
  dplyr::select(stratum, depth, resolution, decay_constant)

```

```{r Pairwise comparison of decay between rare and commmon spp, echo=FALSE}

### This chunk is to test if the decline is flatter after introducing observer error among minor vs. major species, using pairwise Wilcoxon tests.
### Use '[main code] R2 decline vs. observer error' chunk with settings 'shuffle_fraction = "rare/common" ' and import 'final.df_rare' and 'final.df_common' here manually


## load datasets with rare and common species and synchronize maximum error rate with cutoff
# rare species
final.df_rare2 <- final.df_globalabd_rare
final.df_rare2$dataset <- "rare"

## get maximum error rate for rare species to synchronize
# depth level = species
max_error_rare_understory_depth_esp <- max(final.df_rare2 %>% 
                                   filter(stratum == "understory" & depth == "depth_esp") %>% pull(error))
max_error_rare_canopy_depth_esp <- max(final.df_rare2 %>% 
                                   filter(stratum == "canopy"& depth == "depth_esp") %>% pull(error))
# depth level = genus
max_error_rare_understory_depth_gen <- max(final.df_rare2 %>% 
                                            filter(stratum == "understory" & depth == "depth_gen") %>% pull(error))
max_error_rare_canopy_depth_gen <- max(final.df_rare2 %>% 
                                         filter(stratum == "canopy"& depth == "depth_gen") %>% pull(error))
# depth level = family
max_error_rare_understory_depth_fam <- max(final.df_rare2 %>% 
                                            filter(stratum == "understory" & depth == "depth_fam") %>% pull(error))
max_error_rare_canopy_depth_fam <- max(final.df_rare2 %>% 
                                         filter(stratum == "canopy"& depth == "depth_fam") %>% pull(error))

# common species
final.df_common2 <- final.df_globalabd_common %>% 
  filter( # synchronize with rare species dataset
    (stratum == "understory" & depth == "depth_esp" & error <= max_error_rare_understory_depth_esp) |
    (stratum == "understory" & depth == "depth_gen" & error <= max_error_rare_understory_depth_gen) |
    (stratum == "understory" & depth == "depth_fam" & error <= max_error_rare_understory_depth_fam) |
    (stratum == "canopy" & depth == "depth_esp" & error <= max_error_rare_canopy_depth_esp) |
    (stratum == "canopy" & depth == "depth_gen" & error <= max_error_rare_canopy_depth_gen) |
    (stratum == "canopy" & depth == "depth_fam" & error <= max_error_rare_canopy_depth_fam)
    )

final.df_common2$dataset <- "common"

# join datasets
final.df_common_rare <- bind_rows(final.df_rare2, final.df_common2)



#### (A.) Fit exponential decay models ####
#### (A.1) common species ####
lst <- list()
data <- final.df_common_rare %>% 
  filter(dataset == "common" & fraction == "global" & valuetype == "adjR2") %>% 
  dplyr::select(-fraction, -valuetype)

# Function to check if value decreases (or stays the same) as error increases
is_monotonic_decreasing <- function(error, value) {
  ordered <- order(error)
  all(diff(value[ordered]) <= 0)
}


for (h in unique(data$stratum)) {
  
  # get dynamic 'nperm'
  nperm_temp <- max(data$nperm)
  
  # initiate list
  parm_list <- list()
  
  for (i in unique(data$depth)) { # loop over depth
    for (j in unique(data$resolution)) { # loop over resolution
      
      ## let's try with global R2 decline
      df1 <- data %>% 
        filter(stratum == h) %>% 
        filter(depth == i) %>% 
        filter(resolution == j) %>%
        group_by(nperm) %>%
        filter(is_monotonic_decreasing(error, value)) %>% # keep only nperms where value decreases with error
        # filter(max(value) - min(value) > 0.005) %>%
        ungroup()
      
      
      ## fit nonlinear model only if variance is non-zero (this avoids fitting models to horizontal lines)
      if (var(df1$value) != 0) {
        
        ## fit dose-response-curve (dose = error; response = adjR2)
        # Function "DRC.expoDecay()" cannot be found but "[...] the ‘drc’ package also contains the function ‘EXD.2()’, that fits an exponential decay model, with a slightly different parameterisation: 𝑌=𝑑exp(−𝑥/𝑒)."
 
        ## wrap into try() because function 'drm' will fail in case R2 increases with OE
        result <- try(drm(value~error,
                curveid = nperm, # grouping variable [resolution]
                data = df1, 
                fct = EXD.2()),
            silent = TRUE)
  
        
        # Check if the result is an error, and if so, set to NA
        if (inherits(result, "try-error")) { # set result NA in case function fails...
          
          parm_list[[i]][[j]] <- NULL } else { # ...otherwise capture result
            
          drm.fit <- result
          
          ## extract how many models are sgnificantly different from zero
        p_values <- coef(summary(drm.fit))[, "p-value"]
        # delete all intercepts 'd'
        p_values <- p_values[!grepl("^d", names(p_values))]
        # how many percent of decay constants are significantly different from zero?
        signfct_decay_prop <- sum(!is.nan(p_values) & p_values < 0.05) / length(p_values) * 100
          
          
          # get model fit parameters (1st row = intercept, 2nd row = )
          drm.fit.parm <- as.data.frame(drm.fit$parmMat) %>% 
            mutate(depth = i) %>% 
            mutate(resolution = j) %>% 
            mutate(type = c("d", "e"))
          
          parm_list[[i]][[j]] <- drm.fit.parm
          
          
          colvec <- viridis(nperm_temp)
          
          ## plot models
          # DRC package and ggplot? https://stackoverflow.com/questions/36780357/plotting-dose-response-curves-with-ggplot2-and-drc
          plot(drm.fit, 
               xlim = c(min(unlist(errors)), max(unlist(errors))), 
               ylim = c(0, 0.35),
               col = colvec,
               lty = c(rep(1,nperm_temp)), # make all curves 'simple'
               pch = NA,
               cex.legend = 0.7,
               main = paste0("Fitted exponential decay model \n common spp. ", i, " / ", j)) # remove points
          
          
        } # end try if statement
      } # end zero-variance if statement
      
        
        
      } # end j loop (resolution)
    } # close i loop (depth)
  
  ## assemble all parameters
  if (length(parm_list)!=0) {
      lst[[h]] <- bind_rows(bind_rows(parm_list[[1]]), bind_rows(parm_list[[2]]), bind_rows(parm_list[[3]])) %>% 
    pivot_longer(., cols = c(rep(1:max(data$nperm))), names_to = "nperm", values_to = "value") %>% 
    mutate(stratum = h)
  } else {
    lst[[h]] <- NULL
  }

  
  
  } # close h loop (stratum)


# unlist list element
parm_all_common <- bind_rows(lst) %>% distinct() %>% 
  mutate(dataset = "common")
  



#### (A.2) Rare species ####

lst <- list()
data <- final.df_common_rare %>% 
  filter(dataset == "rare" & fraction == "global" & valuetype == "adjR2") %>% 
  dplyr::select(-fraction, -valuetype)

for (h in unique(data$stratum)) {
  
  # get dynamic 'nperm'
  nperm_temp <- max(data$nperm)
  
  # initiate list
  parm_list <- list()
  
  for (i in unique(data$depth)) { # loop over depth
    for (j in unique(data$resolution)) { # loop over resolution
      
      ## let's try with global R2 decline
      df1 <- data %>% 
        filter(stratum == h) %>% 
        filter(depth == i) %>% 
        filter(resolution == j) %>%
        group_by(nperm) %>%
        filter(is_monotonic_decreasing(error, value)) %>% # keep only nperms where value decreases with error
        ungroup()
      
      ## fit nonlinear model only if variance is non-zero (this avoids fitting models to horizontal lines)
      if (var(df1$value) != 0) {
        
        ## fit dose-response-curve (dose = error; response = adjR2)
        # Function "DRC.expoDecay()" cannot be found but "[...] the ‘drc’ package also contains the function ‘EXD.2()’, that fits an exponential decay model, with a slightly different parameterisation: 𝑌=𝑑exp(−𝑥/𝑒)."
        
        ## wrap into try() because function 'drm' will fail in case R2 increases with OE
        result <- try(drm(value~error,
                          curveid = nperm, # grouping variable [resolution]
                          data = df1, 
                          fct = EXD.2()),
                      silent = TRUE)
        
        # p_values <- coef(summary(result))[, "p-value"]
        # # delete all intercepts 'd'
        # p_values <- p_values[!grepl("^d", names(p_values))]
        # # how many percent of decay constants are significantly different from zero?
        # signfct_decay_prop <- sum(!is.nan(p_values) & p_values < 0.05) / length(p_values) * 100
        
        # Check if the result is an error, and if so, set to NA
        if (inherits(result, "try-error")) { # set result NA in case function fails...
          
          parm_list[[i]][[j]] <- NULL } else { # ...otherwise capture result
            
        drm.fit <- result

            
        ### extract how many models are sgnificantly different from zero
        p_values <- coef(summary(drm.fit))[, "p-value"]
        # delete all intercepts 'd'
        p_values <- p_values[!grepl("^d", names(p_values))]
        # how many percent of decay constants are significantly different from zero?
        signfct_decay_prop <- sum(!is.nan(p_values) & p_values < 0.05) / length(p_values) * 100
            
            
            # get model fit parameters (1st row = intercept, 2nd row = )
            drm.fit.parm <- as.data.frame(drm.fit$parmMat) %>% 
              mutate(depth = i) %>% 
              mutate(resolution = j) %>% 
              mutate(type = c("d", "e"))
            
            parm_list[[i]][[j]] <- drm.fit.parm
            
            
            colvec <- viridis(nperm_temp)
            
            ## plot models
            # DRC package and ggplot? https://stackoverflow.com/questions/36780357/plotting-dose-response-curves-with-ggplot2-and-drc
            plot(drm.fit, 
                 xlim = c(min(unlist(errors)), max(unlist(errors))), 
                 ylim = c(0, 0.35),
                 col = colvec,
                 lty = c(rep(1,nperm_temp)), # make all curves 'simple'
                 pch = NA,
                 cex.legend = 0.7,
                 main = paste0("Fitted exponential decay model \n rare spp. ", i, " / ", j)) # remove points
            
            
          } # end try if statement
      } # end zero-variance if statement
      
      
      
    } # end j loop (resolution)
  } # close i loop (depth)
  
  ## assemble all parameters
    if (length(parm_list)!=0) {
      lst[[h]] <- bind_rows(bind_rows(parm_list[[1]]), bind_rows(parm_list[[2]]), bind_rows(parm_list[[3]])) %>% 
    pivot_longer(., cols = c(rep(1:max(data$nperm))), names_to = "nperm", values_to = "value") %>% 
    mutate(stratum = h) 
      } 
  else {
      lst[[h]] <- NULL
    }
  
  
} # close h loop (stratum)


# unlist list element
parm_all_rare <- bind_rows(lst) %>% distinct() %>% 
  mutate(dataset = "rare")




#### (B) Statistical testing ####
## Data are paired, therefore, use either paired t-test or wilcoxon signed-rank test
data2 <- bind_rows(parm_all_rare, parm_all_common) %>% 
  filter(type == "e")

## create dataframe
pairwise_tests_rarecommon <- as.data.frame(matrix(ncol = 4, nrow = 18)) %>% 
  rename(stratum = 1, depth = 2, resolution = 3, pval = 4)

counter <- 1

for (h in unique(data2$stratum)) { # loop over stratum
  for (i in unique(data2$depth)) { # loop over depth
    for (j in unique(data2$resolution)) { # loop over resolution
      
      df2 <- data2 %>% 
        filter(stratum == h) %>% 
        filter(depth == i) %>% 
        filter(resolution == j)
      
      # extract decay constant for common species shuffling
      x1 <- df2 %>% 
        filter(dataset == "common") %>% 
        pull(value)
      # extract decay constant for rare species shuffling
      x2 <- df2 %>% 
        filter(dataset == "rare") %>% 
        pull(value)
      
      
      if (length(x1) != 0 & length(x2) != 0) {
        
        ## Run Wilcoxon Signed-Rank Test
        # hypthesis is that decline for 'common' is steeper than for 'rare', i.e., that lower 'e' is lower for x1 than for x2
        result <- wilcox.test(x1, x2, alternative = "less", paired = TRUE)
        
        # extract p-value
        (pval <- result[[3]])
        
      } else {pval <- NA}
      
      
      ## save result to dataframe
      pairwise_tests_rarecommon[counter,1] <- h
      pairwise_tests_rarecommon[counter,2] <- i
      pairwise_tests_rarecommon[counter,3] <- j
      pairwise_tests_rarecommon[counter,4] <- pval
      
      # update counter
      counter <- counter + 1
        
    }
  }
}

# remove empty rows
pairwise_tests_rarecommon <- pairwise_tests_rarecommon %>% 
  filter(!is.na(pval))

# reordering factor levels
pairwise_tests_rarecommon$stratum <- factor(pairwise_tests_rarecommon$stratum, levels = c("understory", "canopy"))
pairwise_tests_rarecommon$resolution <- factor(pairwise_tests_rarecommon$resolution, levels = c("strict_sp", "morpho_sp", "genus", "family"))
pairwise_tests_rarecommon$depth <- factor(pairwise_tests_rarecommon$depth, levels = c("depth_esp", "depth_gen", "depth_fam"))

## calculate means and standard deviations of 
pairwise_tests_rarecommon_final <- data2 %>% 
  group_by(stratum, depth, resolution) %>% 
  summarise(
    mean_rare = mean(value[dataset == "rare"], na.rm = TRUE),
    sd_rare = sd(value[dataset == "rare"], na.rm = TRUE),
    mean_common = mean(value[dataset == "common"], na.rm = TRUE),
    sd_common = sd(value[dataset == "common"], na.rm = TRUE)
  ) %>% 
  left_join(., pairwise_tests_rarecommon, by = c("stratum", "depth", "resolution")) %>% 
  ungroup() %>% 
  mutate_all(~ifelse(is.nan(.), NA, .)) %>% 
  mutate(rare = paste0(round(mean_rare,2), " ± ", round(sd_rare,2))) %>% 
  mutate(common = paste0(round(mean_common,2), " ± ", round(sd_common,2))) %>% 
  dplyr::select(stratum, depth, resolution, common, rare, pval)


write.csv(pairwise_tests_rarecommon_final, file = "pairwise_tests_rarecommon_final.csv")

## export table to word
library(officer)
# Create a Word document
doc <- read_docx() %>%
  body_add_table(pairwise_tests_rarecommon_final, style = "table_template")
# Save the Word document
print(doc, target = "pairwise_tests_rarecommon_final.docx")

```

```{r Rarefaction of abundant species, echo=FALSE}
### Objective: This chunk rarefies abundant species to emulate the abundance pattern of rare species by (a) translating their abundance profile (min and max occurrences) to matche the values of rare species (b) calculating 

#### set parameters ####
stratum <- "canopy" # set stratum
commonness_cutoff <- 0.5 # use threshold of 0.5 for paper
nperm_rda_global <- 999 # nb. of RDAs to run
rda_nperm <- 999 # set number of permutations for RDA significance test
plot_loss_threshold <- 0.1 # threshold for the subsetting loop for rare species. this is needed because when subsetting rare species, it is highly likely to have plots with 0 species. when we then remove these plots, we have a reduction in dimensionality that could affect RDA. This threshold specifies the maximum allowed loss of sampling sites when subsetting rare species.


#### (A.) discriminating rare from abundant species ####
if (stratum == "understory") {
  rare <- community_data[["understory"]] %>% 
    filter(!is.na(tax_sp_level)) %>% 
    filter(tax_sp_level != "indet. indet.") %>% 
    dplyr::count(tax_sp_level) %>% 
    arrange(desc(n)) %>% 
    mutate(is.rare = n <= quantile(n, perc_cutoff))
} else if (stratum == "canopy") {
  rare <- community_data[["canopy"]] %>% 
    filter(!is.na(tax_sp_level)) %>% 
    filter(tax_sp_level != "indet. indet.") %>% 
    dplyr::count(tax_sp_level) %>% 
    arrange(desc(n)) %>% 
    mutate(is.rare = n <= quantile(n, perc_cutoff))
}

# get number of common species for dataset
(n_common <- nrow(rare %>% filter(is.rare == FALSE)))
(n_rare <- nrow(rare %>% filter(is.rare == TRUE)))


#### (B.) Transpose intervals of common species to match intervals of rare species ####

# bottom of interval that is to be transposed
a <- rare %>% filter(is.rare == FALSE) %>% last() %>% dplyr::select(n) %>% as.integer
# top of interval that is to be transposed
b <- rare %>% filter(is.rare == FALSE) %>% first() %>% dplyr::select(n) %>% as.integer
# bottom of target interval
c <- rare %>% filter(is.rare == TRUE) %>%  last() %>% dplyr::select(n) %>% as.integer
# top of target interval
d <- rare %>% filter(is.rare == TRUE) %>%  first() %>% dplyr::select(n) %>% as.integer


# map values onto another interval: https://math.stackexchange.com/questions/914823/shift-numbers-into-a-different-range

# Function to map a value from the interval [a, b] to [c, d]
map_value <- function(x, a, b, c, d) {
  y <- c + ((x - a) * (d - c)) / (b - a)
  return(y)
}

# get dataframe to be transposed
common_trsnpd <- rare %>% filter(is.rare == FALSE) %>% 
  mutate(n_trnspd = as.integer(sapply(n, map_value, a = a, b = b, c = c, d = d)))


#### (C.) subset individuals at random and run RDA in loop ####
### We have rescaled the abundances of 'abundant species' to match the abundance interval of 'sparse species'. Now, we subsample the set of common species to match that of sparse species (i.e., Aucoumea klaineana is present with 1000 stems in the dataset, we would subsample 5 stems, if the rescaled abundance if 5 [= abundance of the most abundant 'sparse species'])

# dataframe to capture results
rda_trnspd <- data.frame(
  adjR2 = numeric(0),
  pval = numeric(0),
  soil = numeric(0),
  climate = numeric(0),
  human = numeric(0),
  space = numeric(0)
)


tic()
for (i in 1:nperm_rda_global) {
  
  print(paste0("calculating ", i, " out of ", nperm_rda_global, " RDAs for rarefied abundant species."))
  
  ## select only common spp
  if (stratum == "canopy") {
    spp_meta2_subset <- community_data[["canopy"]] %>% 
      filter(tax_sp_level %in% common_trsnpd$tax_sp_level) %>% 
      group_by(tax_sp_level) %>%
      left_join(., common_trsnpd, by = "tax_sp_level") %>% 
      group_modify(~ sample_n(.x, .x$n_trnspd[1], replace = TRUE)) %>%   # Apply sample_n() to each species group
      ungroup()
  } else if (stratum == "understory") {
    spp_meta2_subset <- community_data[["understory"]] %>% 
      filter(tax_sp_level %in% common_trsnpd$tax_sp_level) %>% 
      group_by(tax_sp_level) %>%
      left_join(., common_trsnpd, by = "tax_sp_level") %>% 
      group_modify(~ sample_n(.x, .x$n_trnspd[1], replace = TRUE)) %>%   # Apply sample_n() to each species group
      ungroup()
  }
  
  
  # build community data matrix
  cdm <- spp_meta2_subset %>% 
    group_by(plot_name, tax_sp_level) %>% 
    count() %>% 
    reshape::cast(., plot_name ~ tax_sp_level, value='n') %>%
    mutate_all(~replace(., is.na(.), 0)) %>%
    column_to_rownames(., var = "plot_name")
  
  # match 'env' and 'cdm'
  env_matched <- env_rda %>% 
    rownames_to_column(var = "plot_name") %>% 
    filter(plot_name %in% rownames(cdm)) %>% 
    column_to_rownames(var = "plot_name")
  
  ## create subsets of environmental predictors
  env_matched_clim <- env_matched %>% dplyr::select(any_of(climate_vars))
  env_matched_soiltopo <- env_matched %>% dplyr::select(any_of(c(soil_vars, topo_vars))) # soil & topo
  env_matched_human <- env_matched %>% dplyr::select(intersect(human_vars, names(env_rda))) # human only
  env_matched_space <- env_matched %>% dplyr::select(starts_with("MEM")) # human only
  
  
  ## run RDA
  # Initialize a data frame or list to store results
  results <- data.frame(adjR2 = numeric(), p_value = numeric(), stringsAsFactors = FALSE)
  
  # Loop through BCC exponents and calculate RDA
  rda_results <- sapply(bcc_exp_list, function(bcc) {
    cdm_bcc <- box.cox.chord(cdm, bc.exp = bcc)
    
    # Fit RDA or CAP scale model
    rda_temp <- vegan::rda(cdm_bcc ~ ., env_matched, na.action = na.omit)
    
    # Calculate adjusted R-squared
    adj_r2 <- RsquareAdj(rda_temp)$adj.r.squared
    
    # Perform ANOVA to get p-value
    anova_results <- anova(rda_temp, permutations = rda_nperm)
    p_value <- anova_results$`Pr(>F)`[1]  # Get p-value
    
    ### retrieve partial adjR2 values from varpart
    if (ncol(env_matched_space) > 0) {
      varpart <- varpart(cdm_bcc, env_matched_soiltopo, env_matched_clim, env_matched_human, env_matched_space)
    
      # 'pure' & spatial fractions with the remaining two parcelled out
      adj_r2_soil <- as.data.frame(varpart$part$contr2)[3,3] # soil & soil+space | climate & human [ah]
      adj_r2_climate <- as.data.frame(varpart$part$contr2)[6,3] # climate & climate+space | soil & human [bi]
      adj_r2_human <- as.data.frame(varpart$part$contr2)[9,3] # human & human+space | soil & climate [cj]
      
      adj_r2_space_pure <- as.data.frame(varpart$part$indfract)[4,3] # spatial predictors pure fraction
      
      # Return a named vector of results
      return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil_pure = adj_r2_soil, adj_r2_climate_pure = adj_r2_climate, adj_r2_human_pure = adj_r2_human, adj_r2_space_pure = adj_r2_space_pure))
      
      } else {
      varpart <- varpart(cdm_bcc, env_matched_soiltopo, env_matched_clim, env_matched_human)
      
      adj_r2_soil <- as.data.frame(varpart$part$fract)[1,3] # soil X1 [adfg]
      adj_r2_climate <- as.data.frame(varpart$part$fract)[2,3] # climate X2 [bdeg]
      adj_r2_human <- as.data.frame(varpart$part$fract)[3,3] # human X3 [cefg]
      
      # Return a named vector of results
      return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human))
      
    }
    
  })
  
  # Convert results to a data frame for easier manipulation
  results <- as.data.frame(t(rda_results))
  
  # Find the maximum adjusted R-squared and corresponding p-value
  rda_trnspd[i,1] <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2"])
  rda_trnspd[i,2] <- as.numeric(results[which.max(results$adj_r2), ]["p_value"])
  
  if (ncol(env_matched_space) > 0) {
  rda_trnspd[i,3] <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_soil_pure"])
  rda_trnspd[i,4] <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_climate_pure"])
  rda_trnspd[i,5] <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_human_pure"])
  rda_trnspd[i,6] <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_space_pure"])
  } else {
    rda_trnspd[i,3] <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_soil"])
    rda_trnspd[i,4] <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_climate"])
    rda_trnspd[i,5] <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_human"])
    rda_trnspd[i,6] <- NA
  }
  
} # end main loop
toc()


#### (D.) calculate RDA with rare species ####

## select only rare spp
if (stratum == "canopy") {
  spp_meta2_subset_rare <- community_data[["canopy"]] %>%
    filter(!is.na(tax_sp_level)) %>%
    left_join(., rare, by = "tax_sp_level") %>%
    filter(is.rare == TRUE)
} else if (stratum == "understory") {
  spp_meta2_subset_rare <- community_data[["understory"]] %>%
    filter(!is.na(tax_sp_level)) %>%
    left_join(., rare, by = "tax_sp_level") %>%
    filter(is.rare == TRUE)
}

# build community data matrix
cdm <- spp_meta2_subset_rare %>%
  group_by(plot_name, tax_sp_level) %>%
  count() %>%
  reshape::cast(., plot_name ~ tax_sp_level, value='n') %>%
  mutate_all(~replace(., is.na(.), 0)) %>%
  column_to_rownames(., var = "plot_name")

# match 'env' and 'cdm'
env_matched2 <- env_rda %>% 
  rownames_to_column(var = "plot_name") %>% 
  filter(plot_name %in% rownames(cdm)) %>% 
  column_to_rownames(var = "plot_name")

## create subsets of environmental predictors
env_matched2_clim <- env_matched2 %>% dplyr::select(any_of(climate_vars))
env_matched2_soiltopo <- env_matched2 %>% dplyr::select(any_of(c(soil_vars, topo_vars))) # soil & topo
env_matched2_human <- env_matched2 %>% dplyr::select(intersect(human_vars, names(env_rda))) # human only
env_matched2_space <- env_matched2 %>% dplyr::select(starts_with("MEM")) # human only



### run RDA
# Loop through BCC exponents and calculate RDA
rda_results <- sapply(bcc_exp_list, function(bcc) {
  cdm_bcc <- box.cox.chord(cdm, bc.exp = bcc)

  # Fit RDA or CAP scale model
  rda_temp <- vegan::rda(cdm_bcc ~ ., env_matched2, na.action = na.omit)

  # Calculate adjusted R-squared
  adj_r2 <- RsquareAdj(rda_temp)$adj.r.squared

  # Perform ANOVA to get p-value
  anova_results <- anova(rda_temp, permutations = rda_nperm)
  p_value <- anova_results$`Pr(>F)`[1]  # Get p-value

  ### retrieve partial adjR2 values from varpart
  if (ncol(env_matched_space) > 0) {
    varpart <- varpart(cdm_bcc, env_matched2_soiltopo, env_matched2_clim, env_matched2_human, env_matched2_space)
    
    # 'pure' & spatial fractions with the remaining two parcelled out
    adj_r2_soil <- as.data.frame(varpart$part$contr2)[3,3] # soil & soil+space | climate & human [ah]
    adj_r2_climate <- as.data.frame(varpart$part$contr2)[6,3] # climate & climate+space | soil & human [bi]
    adj_r2_human <- as.data.frame(varpart$part$contr2)[9,3] # human & human+space | soil & climate [cj]
    
    adj_r2_space_pure <- as.data.frame(varpart$part$indfract)[4,3] # spatial predictors pure fraction
    
    # Return a named vector of results
    return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil_pure = adj_r2_soil, adj_r2_climate_pure = adj_r2_climate, adj_r2_human_pure = adj_r2_human, adj_r2_space_pure = adj_r2_space_pure))
    
  } else {
    varpart <- varpart(cdm_bcc, env_matched2_soiltopo, env_matched2_clim, env_matched2_human)
    
    adj_r2_soil <- as.data.frame(varpart$part$fract)[1,3] # soil X1 [adfg]
    adj_r2_climate <- as.data.frame(varpart$part$fract)[2,3] # climate X2 [bdeg]
    adj_r2_human <- as.data.frame(varpart$part$fract)[3,3] # human X3 [cefg]
    
    # Return a named vector of results
    return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human))
    
  }

  # Return a named vector of results
  return(c(adj_r2 = adj_r2, p_value = p_value, adj_r2_soil = adj_r2_soil, adj_r2_climate = adj_r2_climate, adj_r2_human = adj_r2_human))
})

# Convert results to a data frame for easier manipulation
results <- as.data.frame(t(rda_results))

adjR2_rare <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2"])
adjR2_pval <- as.numeric(results[which.max(results$adj_r2), ]["p_value"])

if (ncol(env_matched2_space) > 0) {
  adjR2_soil <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_soil_pure"])
  adjR2_climate <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_climate_pure"])
  adjR2_human <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_human_pure"])
  adjR2_space <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_space_pure"])
} else {
  adjR2_soil <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_soil"])
  adjR2_soil <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_climate"])
  adjR2_soil <- as.numeric(results[which.max(results$adj_r2), ]["adj_r2_human"])
}


rm(results)


#### (E.) compare results ####

## (E.1) rarefied common species
# discard non-significant RDAs
rda_common_rarefied <- rda_trnspd %>% 
  filter(pval <= 0.05) %>% # discard non-significant models
  mutate(type = "common_rarified")


## (E.2) plot histogram of R2 values
ggplot(rda_common_rarefied, aes(x = adjR2)) + 
  geom_histogram(color = "darkgrey", binwidth = 0.001) + 
  xlim(0,0.1) +
  theme_minimal() +
  geom_vline(xintercept = mean(adjR2_rare), color = "blue")


## (E.3) statistical comparison

# normality assumption (Shapiro-Wilk test)
# normality can be assumed if shapiro test is n.s.
(swt <- rda_common_rarefied %>%
    rstatix::shapiro_test(adjR2))

## Global R2
(test <- rda_common_rarefied %>% 
    wilcox_test(adjR2 ~ 1, mu = adjR2_rare))



print(paste0("Mean R2 of rarefied abundant species = ", round(mean(rda_common_rarefied$adjR2),3), " ± ", round(sd(rda_common_rarefied$adjR2),3)))
print(paste0("R2 of rare species = ", round(adjR2_rare,3)))


```
